{"version":3,"sources":["../src/stt/reset-stt-logic.ts","../src/stt/vad-controller.ts","../src/internal/speech-state.ts","../src/tts/audio-player.ts","../src/tts/piper-synthesizer.ts","../src/tts/filler-manager.ts","../src/stt/stt-logic.ts","../src/tts/prepare-piper-voice.ts","../src/tts/stream-tokens-to-speech.ts","../src/tts/ort-setup.ts","../src/tts/piper.ts","../src/tts/use-streaming-tts.ts"],"names":["ResetSTTLogic"],"mappings":"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","file":"index.mjs","sourcesContent":["/**\r\n * stt-tts-lib - Speech-to-Text and Text-to-Speech Library\r\n * Copyright (C) 2026 Navgurukul\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\nexport type ResetReason = \"silence\" | \"utterance-complete\" | \"manual\";\r\n\r\nexport interface ResetStats {\r\n  utteranceStartedAt: number;\r\n  lastActivityAt: number;\r\n  partialTranscript: string;\r\n}\r\n\r\nexport interface ResetSTTOptions {\r\n  /** Maximum silence (ms) allowed before forcing a reset. */\r\n  maxSilenceMs?: number;\r\n  /** Maximum utterance length (ms) before rotating to a fresh buffer. */\r\n  maxUtteranceMs?: number;\r\n  /** Optional reset hook for logging/analytics. */\r\n  onReset?: (reason: ResetReason, stats: ResetStats) => void;\r\n  /**\r\n   * Supply a clock for deterministic tests; defaults to Date.now.\r\n   * Using a function keeps the class platform-neutral.\r\n   */\r\n  now?: () => number;\r\n}\r\n\r\n/**\r\n * Tracks speech activity and decides when to reset an STT pipeline so tokens and streams do not grow unbounded.\r\n */\r\nexport class ResetSTTLogic {\r\n  private readonly maxSilenceMs: number;\r\n  private readonly maxUtteranceMs: number;\r\n  private readonly onReset?: (reason: ResetReason, stats: ResetStats) => void;\r\n  private readonly now: () => number;\r\n\r\n  private utteranceStartedAt: number;\r\n  private lastActivityAt: number;\r\n  private partialTranscript = \"\";\r\n\r\n  constructor(options: ResetSTTOptions = {}) {\r\n    this.maxSilenceMs = options.maxSilenceMs ?? 2000;\r\n    this.maxUtteranceMs = options.maxUtteranceMs ?? 15000;\r\n    this.onReset = options.onReset;\r\n    this.now = options.now ?? (() => Date.now());\r\n\r\n    const start = this.now();\r\n    this.utteranceStartedAt = start;\r\n    this.lastActivityAt = start;\r\n  }\r\n\r\n  recordSpeechActivity(timestamp?: number): void {\r\n    const now = timestamp ?? this.now();\r\n    this.lastActivityAt = now;\r\n    if (!this.utteranceStartedAt) {\r\n      this.utteranceStartedAt = now;\r\n    }\r\n  }\r\n\r\n  updatePartialTranscript(partial: string, timestamp?: number): void {\r\n    this.partialTranscript = partial;\r\n    this.recordSpeechActivity(timestamp);\r\n  }\r\n\r\n  shouldReset(timestamp?: number): ResetReason | null {\r\n    const now = timestamp ?? this.now();\r\n    const silenceElapsed = now - this.lastActivityAt;\r\n    const utteranceElapsed = now - this.utteranceStartedAt;\r\n\r\n    if (silenceElapsed >= this.maxSilenceMs) {\r\n      return \"silence\";\r\n    }\r\n\r\n    if (utteranceElapsed >= this.maxUtteranceMs) {\r\n      return \"utterance-complete\";\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  maybeReset(timestamp?: number): ResetReason | null {\r\n    const reason = this.shouldReset(timestamp);\r\n    if (reason) {\r\n      this.reset(reason, timestamp);\r\n    }\r\n    return reason;\r\n  }\r\n\r\n  forceReset(reason: ResetReason = \"manual\", timestamp?: number): void {\r\n    this.reset(reason, timestamp);\r\n  }\r\n\r\n  private reset(reason: ResetReason, timestamp?: number): void {\r\n    const now = timestamp ?? this.now();\r\n    const stats: ResetStats = {\r\n      utteranceStartedAt: this.utteranceStartedAt,\r\n      lastActivityAt: this.lastActivityAt,\r\n      partialTranscript: this.partialTranscript,\r\n    };\r\n\r\n    this.utteranceStartedAt = now;\r\n    this.lastActivityAt = now;\r\n    this.partialTranscript = \"\";\r\n\r\n    if (this.onReset) {\r\n      this.onReset(reason, stats);\r\n    }\r\n  }\r\n}\r\n","/**\r\n * stt-tts-lib - Speech-to-Text and Text-to-Speech Library\r\n * Copyright (C) 2026 Navgurukul\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\nimport { MicVAD, getDefaultRealTimeVADOptions } from \"@ricky0123/vad-web\";\r\n\r\nexport type VADControllerOptions = {\r\n  bufferSize?: number;\r\n  minSpeechMs?: number;\r\n  minSilenceMs?: number;\r\n  energyThreshold?: number;\r\n  dynamicThresholdFactor?: number;\r\n  noiseFloorSmoothing?: number;\r\n  noiseFloorDecay?: number;\r\n  maxAmplitude?: number;\r\n};\r\n\r\nexport class VADController {\r\n  private vad: MicVAD | null = null;\r\n  private voiceStartListeners = new Set<() => void>();\r\n  private voiceStopListeners = new Set<() => void>();\r\n  private running = false;\r\n  private options?: VADControllerOptions;\r\n\r\n  constructor(options?: VADControllerOptions) {\r\n    this.options = options;\r\n  }\r\n\r\n  public async start(): Promise<void> {\r\n    if (this.running && this.vad) {\r\n      if (!this.vad.listening) {\r\n        await this.vad.start();\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (\r\n      typeof navigator === \"undefined\" ||\r\n      !navigator.mediaDevices ||\r\n      !navigator.mediaDevices.getUserMedia\r\n    ) {\r\n      throw new Error(\"Microphone access is not available.\");\r\n    }\r\n\r\n    try {\r\n      const ortAny = (window as any).ort;\r\n      if (ortAny && ortAny.env && ortAny.env.wasm) {\r\n        ortAny.env.wasm.wasmPaths = \"/ort/\";\r\n      }\r\n\r\n      if (!this.vad) {\r\n        const defaultOptions = getDefaultRealTimeVADOptions(\"v5\");\r\n\r\n        // Configure custom options\r\n        this.vad = await MicVAD.new({\r\n          ...defaultOptions,\r\n          startOnLoad: false,\r\n          onSpeechStart: () => {\r\n            this.emitVoiceStart();\r\n          },\r\n          onSpeechEnd: (audio: Float32Array) => {\r\n            this.emitVoiceStop();\r\n          },\r\n          onVADMisfire: () => {},\r\n          minSpeechMs: this.options?.minSpeechMs || 150,\r\n          positiveSpeechThreshold: 0.5,\r\n          negativeSpeechThreshold: 0.35,\r\n          redemptionMs: this.options?.minSilenceMs || 450,\r\n          preSpeechPadMs: 50,\r\n          processorType: \"ScriptProcessor\",\r\n\r\n          onnxWASMBasePath: \"/ort/\",\r\n          baseAssetPath: \"/vad/\",\r\n          workletOptions: {},\r\n        });\r\n      }\r\n\r\n      if (!this.vad.listening) {\r\n        await this.vad.start();\r\n      }\r\n\r\n      this.running = true;\r\n    } catch (error: any) {\r\n      this.running = false;\r\n      throw new Error(\r\n        error?.message || \"Failed to initialize voice activity detector\"\r\n      );\r\n    }\r\n  }\r\n\r\n  public stop(): void {\r\n    if (!this.running || !this.vad) return;\r\n    try {\r\n      this.vad.pause();\r\n      this.running = false;\r\n    } catch (error) {}\r\n  }\r\n\r\n  public destroy(): void {\r\n    this.stop();\r\n    if (this.vad) {\r\n      try {\r\n        this.vad.destroy();\r\n      } catch (error) {}\r\n      this.vad = null;\r\n    }\r\n    this.voiceStartListeners.clear();\r\n    this.voiceStopListeners.clear();\r\n  }\r\n\r\n  public isActive(): boolean {\r\n    return this.running && this.vad !== null && this.vad.listening;\r\n  }\r\n\r\n  public onVoiceStart(listener: () => void): () => void {\r\n    this.voiceStartListeners.add(listener);\r\n    return () => this.voiceStartListeners.delete(listener);\r\n  }\r\n\r\n  public onVoiceStop(listener: () => void): () => void {\r\n    this.voiceStopListeners.add(listener);\r\n    return () => this.voiceStopListeners.delete(listener);\r\n  }\r\n\r\n  private emitVoiceStart(): void {\r\n    this.voiceStartListeners.forEach((listener) => {\r\n      try {\r\n        listener();\r\n      } catch (error) {\r\n        console.error(\"Error in voice start listener:\", error);\r\n      }\r\n    });\r\n  }\r\n\r\n  private emitVoiceStop(): void {\r\n    this.voiceStopListeners.forEach((listener) => {\r\n      try {\r\n        listener();\r\n      } catch (error) {\r\n        console.error(\"Error in voice stop listener:\", error);\r\n      }\r\n    });\r\n  }\r\n}\r\n","/**\r\n * Internal Speech State Manager\r\n *\r\n * Shared state between STTLogic and AudioPlayer.\r\n * NOT exported to consumers - internal library use only.\r\n */\r\n\r\ntype SpeechStateListener = (speaking: boolean) => void;\r\n\r\nclass SpeechStateManager {\r\n  private speaking = false;\r\n  private listeners: SpeechStateListener[] = [];\r\n\r\n  /**\r\n   * Set speaking state (called by STTLogic)\r\n   */\r\n  setSpeaking(speaking: boolean): void {\r\n    if (this.speaking === speaking) return;\r\n    this.speaking = speaking;\r\n    this.listeners.forEach((listener) => listener(speaking));\r\n  }\r\n\r\n  /**\r\n   * Get current speaking state\r\n   */\r\n  isSpeaking(): boolean {\r\n    return this.speaking;\r\n  }\r\n\r\n  /**\r\n   * Subscribe to speaking state changes (called by AudioPlayer)\r\n   */\r\n  onSpeakingChange(listener: SpeechStateListener): () => void {\r\n    this.listeners.push(listener);\r\n    // Return unsubscribe function\r\n    return () => {\r\n      this.listeners = this.listeners.filter((l) => l !== listener);\r\n    };\r\n  }\r\n}\r\n\r\n// Internal singleton - not exported to consumers\r\nexport const internalSpeechState = new SpeechStateManager();\r\n","/**\r\n * stt-tts-lib - Speech-to-Text and Text-to-Speech Library\r\n * Copyright (C) 2026 Navgurukul\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\nimport { internalSpeechState } from \"../internal/speech-state\";\r\n\r\n/**\r\n * Web Audio API Player with Singleton Support\r\n *\r\n * Can be used as:\r\n * 1. Singleton (recommended): sharedAudioPlayer - same queue across entire app\r\n * 2. Custom instance: new AudioPlayer(config) - separate queue\r\n *\r\n * Speech-aware: Automatically pauses queue when user is speaking (via STTLogic).\r\n */\r\n\r\nexport interface AudioPlayerConfig {\r\n  sampleRate?: number;\r\n  volume?: number;\r\n  autoPlay?: boolean;\r\n}\r\n\r\nexport interface QueuedAudio {\r\n  audioData: Float32Array;\r\n  sampleRate: number;\r\n}\r\n\r\nexport type AudioPlayerStatusCallback = (status: string) => void;\r\nexport type PlayingStateCallback = (playing: boolean) => void;\r\n\r\n/**\r\n * Audio Player for Web Audio API\r\n * Supports queue-based playback with autoPlay\r\n */\r\nexport class AudioPlayer {\r\n  private static instance: AudioPlayer | null = null;\r\n  private static sharedConfig: AudioPlayerConfig = {\r\n    sampleRate: 22050,\r\n    volume: 1.0,\r\n    autoPlay: true,\r\n  };\r\n\r\n  private audioContext: AudioContext | null = null;\r\n  private config: AudioPlayerConfig;\r\n  private currentSource: AudioBufferSourceNode | null = null;\r\n\r\n  // Queue-related properties\r\n  private audioQueue: QueuedAudio[] = [];\r\n  private isPlaying = false;\r\n  private isQueueProcessing = false;\r\n  private onStatusCallback?: AudioPlayerStatusCallback;\r\n  private onPlayingChangeCallback?: PlayingStateCallback;\r\n\r\n  // Speech-aware playback: pause queue while user is speaking\r\n  private userSpeaking = false;\r\n  private onUserSpeakingChangeCallback?: (speaking: boolean) => void;\r\n  private speechStateUnsubscribe?: () => void;\r\n\r\n  constructor(config: AudioPlayerConfig = {}) {\r\n    this.config = {\r\n      sampleRate: 22050,\r\n      volume: 1.0,\r\n      autoPlay: false,\r\n      ...config,\r\n    };\r\n\r\n    // Auto-subscribe to internal speech state (from STTLogic)\r\n    this.speechStateUnsubscribe = internalSpeechState.onSpeakingChange(\r\n      (speaking) => {\r\n        this.setUserSpeaking(speaking);\r\n      }\r\n    );\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Singleton Methods (Static)\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Configure the shared singleton (call before first use)\r\n   */\r\n  static configure(config: AudioPlayerConfig): void {\r\n    if (AudioPlayer.instance) {\r\n      console.log(\r\n        \"[AudioPlayer] Singleton already initialized. Call reset() first to reconfigure.\"\r\n      );\r\n      return;\r\n    }\r\n    AudioPlayer.sharedConfig = { ...AudioPlayer.sharedConfig, ...config };\r\n  }\r\n\r\n  /**\r\n   * Get the singleton instance (creates if not exists)\r\n   */\r\n  static getInstance(): AudioPlayer {\r\n    if (!AudioPlayer.instance) {\r\n      AudioPlayer.instance = new AudioPlayer(AudioPlayer.sharedConfig);\r\n      console.log(\r\n        \"[AudioPlayer] Singleton initialized with config:\",\r\n        AudioPlayer.sharedConfig\r\n      );\r\n    }\r\n    return AudioPlayer.instance;\r\n  }\r\n\r\n  /**\r\n   * Reset the singleton (for reconfiguration)\r\n   */\r\n  static async reset(): Promise<void> {\r\n    if (AudioPlayer.instance) {\r\n      await AudioPlayer.instance.close();\r\n      AudioPlayer.instance = null;\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Instance Methods\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Set status callback for logging\r\n   */\r\n  setStatusCallback(callback: AudioPlayerStatusCallback): void {\r\n    this.onStatusCallback = callback;\r\n  }\r\n\r\n  /**\r\n   * Set callback for playing state changes\r\n   */\r\n  setPlayingChangeCallback(callback: PlayingStateCallback): void {\r\n    this.onPlayingChangeCallback = callback;\r\n  }\r\n\r\n  /**\r\n   * Check if audio is currently playing\r\n   */\r\n  isAudioPlaying(): boolean {\r\n    return this.isPlaying;\r\n  }\r\n\r\n  /**\r\n   * Get current queue size\r\n   */\r\n  getQueueSize(): number {\r\n    return this.audioQueue.length;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Speech-Aware Playback\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Set user speaking state\r\n   * When user is speaking, queue playback is paused\r\n   * When user stops speaking, queue playback resumes (if autoPlay enabled)\r\n   */\r\n  setUserSpeaking(speaking: boolean): void {\r\n    if (this.userSpeaking === speaking) return;\r\n\r\n    this.userSpeaking = speaking;\r\n    this.log(`[AudioPlayer] User speaking: ${speaking}`);\r\n    this.onUserSpeakingChangeCallback?.(speaking);\r\n\r\n    // When user stops speaking, resume queue playback if autoPlay is enabled\r\n    if (!speaking && this.config.autoPlay && this.audioQueue.length > 0) {\r\n      this.log(\"[AudioPlayer] User stopped speaking, resuming queue playback\");\r\n      this.playAudiosFromQueue();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if user is currently speaking\r\n   */\r\n  isUserSpeaking(): boolean {\r\n    return this.userSpeaking;\r\n  }\r\n\r\n  /**\r\n   * Set callback for user speaking state changes\r\n   */\r\n  setUserSpeakingChangeCallback(callback: (speaking: boolean) => void): void {\r\n    this.onUserSpeakingChangeCallback = callback;\r\n  }\r\n\r\n  /**\r\n   * Add audio to the queue\r\n   * Note: If user is speaking, audio is queued but NOT played until user stops\r\n   */\r\n  addAudioIntoQueue(audioData: Float32Array, sampleRate?: number): void {\r\n    const audio: QueuedAudio = {\r\n      audioData,\r\n      sampleRate: sampleRate ?? this.config.sampleRate!,\r\n    };\r\n    this.audioQueue.push(audio);\r\n    this.log(\r\n      `[AudioPlayer] Added audio to queue (samples: ${audioData.length}, queue size: ${this.audioQueue.length}, userSpeaking: ${this.userSpeaking})`\r\n    );\r\n\r\n    // Don't start playback if already processing\r\n    if (this.isQueueProcessing) {\r\n      return;\r\n    }\r\n\r\n    // Don't start playback if user is speaking - wait until they stop\r\n    if (this.userSpeaking) {\r\n      this.log(\r\n        \"[AudioPlayer] User is speaking, audio queued but playback paused\"\r\n      );\r\n      return;\r\n    }\r\n\r\n    // Start playback if autoPlay enabled\r\n    if (this.config.autoPlay) {\r\n      this.playAudiosFromQueue();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start playing audios from the queue sequentially\r\n   * Pauses if user starts speaking, resumes when they stop\r\n   */\r\n  async playAudiosFromQueue(): Promise<void> {\r\n    if (this.audioQueue.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Don't start if user is speaking\r\n    if (this.userSpeaking) {\r\n      this.log(\"[AudioPlayer] Cannot start queue playback - user is speaking\");\r\n      return;\r\n    }\r\n\r\n    this.isQueueProcessing = true;\r\n    this.log(\"[AudioPlayer] Starting queue playback\");\r\n\r\n    try {\r\n      while (this.audioQueue.length > 0) {\r\n        // Pause playback if user starts speaking mid-queue\r\n        if (this.userSpeaking) {\r\n          this.log(\r\n            \"[AudioPlayer] User started speaking, pausing queue playback\"\r\n          );\r\n          break;\r\n        }\r\n\r\n        const audio = this.audioQueue.shift();\r\n        if (audio) {\r\n          this.setPlayingState(true);\r\n          await this.play(audio.audioData, audio.sampleRate);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.log(`[AudioPlayer] Queue playback error: ${error}`);\r\n    } finally {\r\n      this.isQueueProcessing = false;\r\n      this.setPlayingState(false);\r\n      this.log(\"[AudioPlayer] Queue playback finished\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Play audio data directly\r\n   */\r\n  async play(audioData: Float32Array, sampleRate: number): Promise<void> {\r\n    const ctx = this.getAudioContext();\r\n\r\n    if (ctx.state === \"suspended\") {\r\n      await ctx.resume();\r\n    }\r\n\r\n    const audioBuffer = ctx.createBuffer(1, audioData.length, sampleRate);\r\n    audioBuffer.getChannelData(0).set(audioData);\r\n\r\n    const source = ctx.createBufferSource();\r\n    source.buffer = audioBuffer;\r\n\r\n    const gainNode = ctx.createGain();\r\n    gainNode.gain.value = this.config.volume!;\r\n\r\n    source.connect(gainNode);\r\n    gainNode.connect(ctx.destination);\r\n\r\n    this.currentSource = source;\r\n    source.start(0);\r\n\r\n    return new Promise<void>((resolve) => {\r\n      source.onended = () => {\r\n        this.currentSource = null;\r\n        resolve();\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Stop current playback (does not clear queue)\r\n   */\r\n  stop(): void {\r\n    if (this.currentSource) {\r\n      try {\r\n        this.currentSource.stop();\r\n        this.currentSource = null;\r\n      } catch (error) {\r\n        // Ignore errors if already stopped\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear the audio queue\r\n   */\r\n  clearQueue(): void {\r\n    this.audioQueue = [];\r\n    this.log(\"[AudioPlayer] Queue cleared\");\r\n  }\r\n\r\n  /**\r\n   * Stop playback and clear the queue\r\n   */\r\n  stopAndClearQueue(): void {\r\n    this.isQueueProcessing = false;\r\n    this.stop();\r\n    this.clearQueue();\r\n    this.setPlayingState(false);\r\n    this.log(\"[AudioPlayer] Stopped playback and cleared queue\");\r\n  }\r\n\r\n  /**\r\n   * Wait for all queued audio to finish playing\r\n   */\r\n  async waitForQueueCompletion(): Promise<void> {\r\n    while (this.audioQueue.length > 0 || this.isPlaying) {\r\n      await new Promise((resolve) => setTimeout(resolve, 50));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set volume (0.0 to 1.0)\r\n   */\r\n  setVolume(volume: number): void {\r\n    this.config.volume = Math.max(0, Math.min(1, volume));\r\n  }\r\n\r\n  /**\r\n   * Close the audio context and free resources\r\n   */\r\n  async close(): Promise<void> {\r\n    this.stop();\r\n    if (this.speechStateUnsubscribe) {\r\n      this.speechStateUnsubscribe();\r\n    }\r\n    if (this.audioContext) {\r\n      await this.audioContext.close();\r\n      this.audioContext = null;\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Private Methods\r\n  // ==========================================================================\r\n\r\n  private setPlayingState(playing: boolean): void {\r\n    if (this.isPlaying !== playing) {\r\n      this.isPlaying = playing;\r\n      this.onPlayingChangeCallback?.(playing);\r\n    }\r\n  }\r\n\r\n  private log(message: string): void {\r\n    console.log(message);\r\n    this.onStatusCallback?.(message);\r\n  }\r\n\r\n  private getAudioContext(): AudioContext {\r\n    if (!this.audioContext) {\r\n      this.audioContext = new (window.AudioContext ||\r\n        (window as any).webkitAudioContext)({\r\n        sampleRate: this.config.sampleRate,\r\n      });\r\n    }\r\n    return this.audioContext;\r\n  }\r\n}\r\n\r\n/**\r\n * Create a new AudioPlayer instance (separate queue)\r\n */\r\nexport function createAudioPlayer(config?: AudioPlayerConfig): AudioPlayer {\r\n  return new AudioPlayer(config);\r\n}\r\n\r\n/**\r\n * Shared AudioPlayer singleton\r\n * Same queue across STTLogic, TTSLogic, and consumer code\r\n *\r\n * Usage:\r\n *   // Configure once (optional)\r\n *   AudioPlayer.configure({ autoPlay: true });\r\n *\r\n *   // Use anywhere - same queue everywhere\r\n *   sharedAudioPlayer.addAudioIntoQueue(audioData, sampleRate);\r\n */\r\nexport const sharedAudioPlayer = {\r\n  /** Configure before first use */\r\n  configure: (config: AudioPlayerConfig) => AudioPlayer.configure(config),\r\n\r\n  /** Get the singleton instance */\r\n  getInstance: () => AudioPlayer.getInstance(),\r\n\r\n  /** Add audio to the shared queue */\r\n  addAudioIntoQueue: (audioData: Float32Array, sampleRate?: number) =>\r\n    AudioPlayer.getInstance().addAudioIntoQueue(audioData, sampleRate),\r\n\r\n  /** Play audio directly */\r\n  play: (audioData: Float32Array, sampleRate: number) =>\r\n    AudioPlayer.getInstance().play(audioData, sampleRate),\r\n\r\n  /** Start playing from queue */\r\n  playAudiosFromQueue: () => AudioPlayer.getInstance().playAudiosFromQueue(),\r\n\r\n  /** Check if playing */\r\n  isAudioPlaying: () => AudioPlayer.getInstance().isAudioPlaying(),\r\n\r\n  /** Get queue size */\r\n  getQueueSize: () => AudioPlayer.getInstance().getQueueSize(),\r\n\r\n  /** Stop playback */\r\n  stop: () => AudioPlayer.getInstance().stop(),\r\n\r\n  /** Clear queue */\r\n  clearQueue: () => AudioPlayer.getInstance().clearQueue(),\r\n\r\n  /** Stop and clear */\r\n  stopAndClearQueue: () => AudioPlayer.getInstance().stopAndClearQueue(),\r\n\r\n  /** Wait for completion */\r\n  waitForQueueCompletion: () =>\r\n    AudioPlayer.getInstance().waitForQueueCompletion(),\r\n\r\n  /** Set volume */\r\n  setVolume: (volume: number) => AudioPlayer.getInstance().setVolume(volume),\r\n\r\n  /** Set status callback */\r\n  setStatusCallback: (callback: AudioPlayerStatusCallback) =>\r\n    AudioPlayer.getInstance().setStatusCallback(callback),\r\n\r\n  /** Set playing state callback */\r\n  setPlayingChangeCallback: (callback: PlayingStateCallback) =>\r\n    AudioPlayer.getInstance().setPlayingChangeCallback(callback),\r\n\r\n  // Speech-aware playback (automatically managed by STTLogic)\r\n  /** Check if user is speaking */\r\n  isUserSpeaking: () => AudioPlayer.getInstance().isUserSpeaking(),\r\n\r\n  /** Set callback for speaking state changes */\r\n  setUserSpeakingChangeCallback: (callback: (speaking: boolean) => void) =>\r\n    AudioPlayer.getInstance().setUserSpeakingChangeCallback(callback),\r\n\r\n  /** Manual override for speaking state (usually not needed - handled by STTLogic) */\r\n  setUserSpeaking: (speaking: boolean) =>\r\n    AudioPlayer.getInstance().setUserSpeaking(speaking),\r\n\r\n  /** Reset singleton */\r\n  reset: () => AudioPlayer.reset(),\r\n\r\n  /** Close */\r\n  close: () => AudioPlayer.reset(),\r\n};\r\n","/**\r\n * stt-tts-lib - Speech-to-Text and Text-to-Speech Library\r\n * Copyright (C) 2026 Navgurukul\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\n/**\r\n * Piper TTS Synthesizer using @realtimex/piper-tts-web\r\n * This library handles text-to-phoneme conversion properly using espeak-ng\r\n *\r\n * Note: @realtimex/piper-tts-web handles ONNX Runtime configuration internally,\r\n * so NO separate ort-setup.js is needed!\r\n */\r\n\r\nimport * as piperTts from \"@realtimex/piper-tts-web\";\r\nimport { AudioPlayer, sharedAudioPlayer } from \"./audio-player\";\r\n\r\nexport interface PiperSynthesizerConfig {\r\n  /** Voice ID (e.g., \"en_US-hfc_female-medium\") */\r\n  voiceId?: string;\r\n  /** Sample rate (default: 22050) */\r\n  sampleRate?: number;\r\n  /** Use shared audio player singleton (default: true) */\r\n  useSharedAudioPlayer?: boolean;\r\n  warmUp?: boolean;\r\n}\r\n\r\nexport interface SynthesisResult {\r\n  /** Audio data as WAV Blob */\r\n  audioBlob: Blob;\r\n  /** Audio data as Float32Array (for direct playback) */\r\n  audio: Float32Array;\r\n  /** Sample rate */\r\n  sampleRate: number;\r\n  /** Duration in seconds */\r\n  duration: number;\r\n}\r\n\r\nconst DEFAULT_VOICE_ID = \"en_US-hfc_female-medium\";\r\n\r\n/**\r\n * Piper TTS Synthesizer\r\n * Uses @mintplex-labs/piper-tts-web for proper text-to-speech conversion\r\n */\r\nexport class TTSLogic {\r\n  private config: PiperSynthesizerConfig;\r\n  private ready = false;\r\n  private voiceLoaded = false;\r\n  private audioPlayer?: AudioPlayer;\r\n  private useSharedPlayer: boolean;\r\n  private warmUp: boolean = true;\r\n\r\n  constructor(config: PiperSynthesizerConfig = {}) {\r\n    this.config = {\r\n      voiceId: DEFAULT_VOICE_ID,\r\n      sampleRate: 22050,\r\n      useSharedAudioPlayer: true,\r\n      warmUp: true,\r\n      ...config,\r\n    };\r\n    this.useSharedPlayer = this.config.useSharedAudioPlayer !== false;\r\n  }\r\n\r\n  /**\r\n   * Set a custom AudioPlayer (disables shared player for this instance)\r\n   */\r\n  setAudioPlayer(player: AudioPlayer): void {\r\n    this.audioPlayer = player;\r\n    this.useSharedPlayer = false;\r\n  }\r\n\r\n  /**\r\n   * Add audio to the queue (uses shared player by default, or custom if set)\r\n   */\r\n  addInternalAudioToQueue(audio: Float32Array, sampleRate?: number): void {\r\n    if (this.audioPlayer) {\r\n      // Use custom player if explicitly set\r\n      this.audioPlayer.addAudioIntoQueue(audio, sampleRate);\r\n    } else if (this.useSharedPlayer) {\r\n      // Use shared singleton player\r\n      sharedAudioPlayer.addAudioIntoQueue(audio, sampleRate);\r\n    }\r\n  }\r\n\r\n  async warmup(text = \"warmup\"): Promise<{ synthesized: boolean }> {\r\n    if (!this.voiceLoaded) {\r\n      throw new Error(\"Voice not loaded. Call initialize() first.\");\r\n    }\r\n    try {\r\n      // Call piperTts.predict directly to avoid ready check (warmup runs before ready=true)\r\n      await piperTts.predict({\r\n        text,\r\n        voiceId: this.config.voiceId!,\r\n      });\r\n      console.log(\" Piper synthesizer warmed up\");\r\n      return { synthesized: true };\r\n    } catch (error) {\r\n      throw new Error(`Failed to warm up Piper synthesizer: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize the synthesizer by loading the voice model\r\n   */\r\n  async initialize(): Promise<void> {\r\n    if (this.ready) return;\r\n\r\n    try {\r\n      const voiceId = this.config.voiceId!;\r\n      console.log(\" Loading Piper voice:\", voiceId);\r\n\r\n      // Check if voice is already cached\r\n      const storedVoices = await piperTts.stored();\r\n      const alreadyCached = Array.isArray(storedVoices)\r\n        ? storedVoices.includes(voiceId)\r\n        : false;\r\n\r\n      if (!alreadyCached) {\r\n        console.log(\" Downloading voice model...\");\r\n        await piperTts.download(voiceId, (progress) => {\r\n          if (progress?.total) {\r\n            const pct = Math.round((progress.loaded * 100) / progress.total);\r\n            console.log(` Downloading: ${pct}%`);\r\n          }\r\n        });\r\n      } else {\r\n        console.log(\" Voice found in cache\");\r\n      }\r\n      this.voiceLoaded = true;\r\n      if (this.config.warmUp) {\r\n        const { synthesized } = await this.warmup();\r\n        if (!synthesized) {\r\n          throw new Error(\r\n            \"Failed to warm up Piper synthesizer. Please check the voice model and try again.\"\r\n          );\r\n        }\r\n      }\r\n      this.ready = true;\r\n      console.log(\" Piper synthesizer initialized\");\r\n    } catch (error) {\r\n      throw new Error(`Failed to initialize Piper synthesizer: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if the synthesizer is ready\r\n   */\r\n  isReady(): boolean {\r\n    return this.ready;\r\n  }\r\n\r\n  /**\r\n   * Synthesize speech from text\r\n   * @param text - Text to convert to speech\r\n   * @returns Audio data as WAV Blob and Float32Array\r\n   */\r\n  async synthesize(text: string): Promise<SynthesisResult> {\r\n    if (!this.ready) {\r\n      throw new Error(\"Synthesizer not initialized. Call initialize() first.\");\r\n    }\r\n\r\n    const trimmed = text?.trim();\r\n    if (!trimmed) {\r\n      throw new Error(\"No text provided for synthesis\");\r\n    }\r\n\r\n    try {\r\n      // Use piper-tts-web to convert text to speech\r\n      // This handles text-to-phoneme conversion internally using espeak-ng\r\n      const wavBlob: Blob = await piperTts.predict({\r\n        text: trimmed,\r\n        voiceId: this.config.voiceId!,\r\n      });\r\n\r\n      // Convert Blob to Float32Array for direct playback\r\n      const arrayBuffer = await wavBlob.arrayBuffer();\r\n      const audioContext = new (window.AudioContext ||\r\n        (window as any).webkitAudioContext)();\r\n      const decodedBuffer = await audioContext.decodeAudioData(arrayBuffer);\r\n      const audioData = decodedBuffer.getChannelData(0);\r\n      audioContext.close();\r\n\r\n      return {\r\n        audioBlob: wavBlob,\r\n        audio: audioData,\r\n        sampleRate: decodedBuffer.sampleRate,\r\n        duration: decodedBuffer.duration,\r\n      };\r\n    } catch (error) {\r\n      throw new Error(`Synthesis failed: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Synthesize and return WAV Blob only (faster, no decoding)\r\n   */\r\n  async synthesizeToBlob(text: string): Promise<Blob> {\r\n    if (!this.ready) {\r\n      throw new Error(\"Synthesizer not initialized. Call initialize() first.\");\r\n    }\r\n\r\n    const trimmed = text?.trim();\r\n    if (!trimmed) {\r\n      throw new Error(\"No text provided for synthesis\");\r\n    }\r\n\r\n    return piperTts.predict({\r\n      text: trimmed,\r\n      voiceId: this.config.voiceId!,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Synthesize text and add to queue (uses shared player by default)\r\n   */\r\n  async synthesizeAndAddToQueue(text: string): Promise<void> {\r\n    if (!this.audioPlayer && !this.useSharedPlayer) {\r\n      throw new Error(\"No AudioPlayer set and shared player is disabled\");\r\n    }\r\n    const result = await this.synthesize(text);\r\n    this.addInternalAudioToQueue(result.audio, result.sampleRate);\r\n  }\r\n\r\n  /**\r\n   * Stop current synthesis (not directly supported, but we can track state)\r\n   */\r\n  stop(): void {\r\n    // Piper doesn't have a stop method, but we track state\r\n    console.log(\"Stop requested\");\r\n  }\r\n\r\n  /**\r\n   * Dispose of the synthesizer and free resources\r\n   */\r\n  async dispose(): Promise<void> {\r\n    this.ready = false;\r\n    this.voiceLoaded = false;\r\n  }\r\n}\r\n\r\n/**\r\n * Create and initialize a Piper synthesizer\r\n */\r\n// export async function createPiperSynthesizer(\r\n//   config: PiperSynthesizerConfig = {}\r\n// ): Promise<PiperSynthesizer> {\r\n//   const synthesizer = new PiperSynthesizer(config);\r\n//   await synthesizer.initialize();\r\n//   return synthesizer;\r\n// }\r\n\r\n/**\r\n * @deprecated Use PiperSynthesizer.synthesize() which handles text-to-phoneme internally\r\n * This is kept for backwards compatibility but should not be used directly\r\n */\r\nexport function textToPhonemes(_text: string): number[] {\r\n  console.warn(\r\n    \"textToPhonemes is deprecated. Use PiperSynthesizer.synthesize(text) instead.\"\r\n  );\r\n  return [];\r\n}\r\n","/**\r\n * stt-tts-lib - Filler Word Manager\r\n *\r\n * Generates contextual filler words using LLM at configurable intervals.\r\n * Audio is synthesized immediately but only plays when user stops speaking.\r\n */\r\n\r\nimport { sharedAudioPlayer } from \"./audio-player\";\r\nimport { internalSpeechState } from \"../internal/speech-state\";\r\nimport { TTSLogic } from \"./piper-synthesizer\";\r\n\r\n// System prompt for early (short) filler - brief acknowledgments\r\nconst SHORT_FILLER_SYSTEM_PROMPT = `\r\nYou are an *interviewer* listening to someone's answer.\r\nGenerate brief, natural filler words that show you're actively listening (5-12 words).\r\n\r\nExamples: \"Okay that makes sense\", \"Right I understand\", \"Got it\", \"I see where you're going\", \"Yeah that's a good point\"\r\n\r\nGuidelines:\r\n- Keep responses 5-12 words, natural and varied\r\n- Reference specific content from their speech if possible\r\n- Avoid punctuation except where natural\r\n- Stay in the same language as the user\r\n- If text is unclear, use generic acknowledgments like \"Okay I'm following\"\r\n\r\nOutput only your brief reaction. No explanations.\r\n`;\r\n\r\n// System prompt for late (long) filler - contextual rephrasing\r\nconst LONG_FILLER_SYSTEM_PROMPT = `\r\nYou are an *interviewer* listening to someone's answer.\r\nYour role is to rephrase what they said to show deep understanding (15-25 words).\r\n\r\nGuidelines:\r\n- Rephrase the user's partial message with specific context\r\n- Extract key concepts and mirror them back\r\n- Examples: \"So you're explaining how [concept] works...\", \"In other words the [topic] connects to...\"\r\n- Keep responses 15-25 words, declarative (not questions)\r\n- Reference their actual words and ideas\r\n- Stay in the same language as the user\r\n\r\nOutput only your contextual rephrasing. No explanations.\r\n`;\r\n\r\nexport interface FillerConfig {\r\n  /** Enable short filler (default: false) */\r\n  enableShortFiller?: boolean;\r\n  /** Enable long filler (default: false) */\r\n  enableLongFiller?: boolean;\r\n  /** Delay before short filler in ms (default: 5000) */\r\n  shortFillerDelayMs?: number;\r\n  /** Delay before long filler in ms (default: 10000) */\r\n  longFillerDelayMs?: number;\r\n  /** Fallback short filler text if LLM fails */\r\n  shortFillerFallback?: string;\r\n  /** Fallback long filler text if LLM fails */\r\n  longFillerFallback?: string;\r\n\r\n  // LLM Configuration\r\n  /** LLM API URL (required for dynamic fillers) */\r\n  llmApiUrl?: string;\r\n  /** LLM API Key */\r\n  llmApiKey?: string;\r\n  /** LLM Model name (default: \"deepseek-chat\") */\r\n  llmModel?: string;\r\n  /** Custom system prompt for short filler */\r\n  shortFillerPrompt?: string;\r\n  /** Custom system prompt for long filler */\r\n  longFillerPrompt?: string;\r\n  /** LLM request timeout in ms (default: 3000) */\r\n  llmTimeoutMs?: number;\r\n  /** Language hint for LLM (e.g., \"English\", \"Hindi\") */\r\n  languageHint?: string;\r\n\r\n  // TTS Configuration\r\n  /** TTS voice ID for filler synthesis (uses default if not set) */\r\n  ttsVoice?: string;\r\n\r\n  /** Callback when filler is generated */\r\n  onFillerGenerated?: (type: \"short\" | \"long\", text: string) => void;\r\n  /** Custom synthesizer function (overrides internal TTS if provided) */\r\n  synthesize?: (\r\n    text: string\r\n  ) => Promise<{ audio: Float32Array; sampleRate: number }>;\r\n}\r\n\r\nconst DEFAULT_CONFIG = {\r\n  enableShortFiller: false,\r\n  enableLongFiller: false,\r\n  shortFillerDelayMs: 5000,\r\n  longFillerDelayMs: 10000,\r\n  shortFillerFallback: \"Okay, I understand.\",\r\n  longFillerFallback: \"Right, that makes sense.\",\r\n  llmModel: \"deepseek-chat\",\r\n  shortFillerPrompt: SHORT_FILLER_SYSTEM_PROMPT,\r\n  longFillerPrompt: LONG_FILLER_SYSTEM_PROMPT,\r\n  llmTimeoutMs: 3000,\r\n  languageHint: \"English\",\r\n};\r\n\r\nexport class FillerManager {\r\n  private config: typeof DEFAULT_CONFIG &\r\n    Pick<\r\n      FillerConfig,\r\n      | \"llmApiUrl\"\r\n      | \"llmApiKey\"\r\n      | \"onFillerGenerated\"\r\n      | \"synthesize\"\r\n      | \"ttsVoice\"\r\n    >;\r\n\r\n  private speechStartedAt = 0;\r\n  private shortFillerTimer: ReturnType<typeof setTimeout> | null = null;\r\n  private longFillerTimer: ReturnType<typeof setTimeout> | null = null;\r\n  private shortFillerGenerated = false;\r\n  private longFillerGenerated = false;\r\n  private unsubscribe?: () => void;\r\n  private currentPartialTranscript = \"\";\r\n  private inFlight = 0;\r\n  private ttsLogic: TTSLogic | null = null;\r\n  private ttsInitPromise: Promise<void> | null = null;\r\n\r\n  // Exposed for consumer to see generated fillers\r\n  public shortFiller: string | null = null;\r\n  public longFiller: string | null = null;\r\n\r\n  constructor(config: FillerConfig = {}) {\r\n    this.config = { ...DEFAULT_CONFIG, ...config };\r\n    this.setupSpeechStateListener();\r\n    this.initializeTTS();\r\n  }\r\n\r\n  private initializeTTS(): void {\r\n    // Only initialize if no custom synthesizer is provided\r\n    if (!this.config.synthesize) {\r\n      this.ttsLogic = new TTSLogic({\r\n        voiceId: this.config.ttsVoice,\r\n        useSharedAudioPlayer: true, // Use shared player for queueing\r\n        warmUp: false,\r\n      });\r\n      this.ttsInitPromise = this.ttsLogic.initialize().catch((err) => {\r\n        console.error(\"[FillerManager] Failed to initialize TTS:\", err);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update configuration\r\n   */\r\n  configure(config: Partial<FillerConfig>): void {\r\n    this.config = { ...this.config, ...config };\r\n  }\r\n\r\n  /**\r\n   * Set the synthesizer function\r\n   */\r\n  setSynthesizer(synthesize: FillerConfig[\"synthesize\"]): void {\r\n    this.config.synthesize = synthesize;\r\n  }\r\n\r\n  /**\r\n   * Update partial transcript (call this on each STT partial result)\r\n   */\r\n  updatePartialTranscript(text: string): void {\r\n    this.currentPartialTranscript = text;\r\n  }\r\n\r\n  private setupSpeechStateListener(): void {\r\n    this.unsubscribe = internalSpeechState.onSpeakingChange((speaking) => {\r\n      if (speaking) {\r\n        this.onSpeechStart();\r\n      } else {\r\n        this.onSpeechEnd();\r\n      }\r\n    });\r\n  }\r\n\r\n  private onSpeechStart(): void {\r\n    this.speechStartedAt = Date.now();\r\n    this.shortFillerGenerated = false;\r\n    this.longFillerGenerated = false;\r\n    this.shortFiller = null;\r\n    this.longFiller = null;\r\n    this.currentPartialTranscript = \"\";\r\n\r\n    console.log(\"[FillerManager] Speech started, scheduling fillers\");\r\n\r\n    // Schedule short filler\r\n    if (this.config.enableShortFiller) {\r\n      this.shortFillerTimer = setTimeout(() => {\r\n        this.generateFiller(\"short\");\r\n      }, this.config.shortFillerDelayMs);\r\n    }\r\n\r\n    // Schedule long filler\r\n    if (this.config.enableLongFiller) {\r\n      this.longFillerTimer = setTimeout(() => {\r\n        this.generateFiller(\"long\");\r\n      }, this.config.longFillerDelayMs);\r\n    }\r\n  }\r\n\r\n  private onSpeechEnd(): void {\r\n    console.log(\"[FillerManager] Speech ended, clearing timers\");\r\n    this.clearTimers();\r\n    this.speechStartedAt = 0;\r\n  }\r\n\r\n  private clearTimers(): void {\r\n    if (this.shortFillerTimer) {\r\n      clearTimeout(this.shortFillerTimer);\r\n      this.shortFillerTimer = null;\r\n    }\r\n    if (this.longFillerTimer) {\r\n      clearTimeout(this.longFillerTimer);\r\n      this.longFillerTimer = null;\r\n    }\r\n  }\r\n\r\n  private async generateFiller(type: \"short\" | \"long\"): Promise<void> {\r\n    // Prevent duplicate generation\r\n    if (type === \"short\" && this.shortFillerGenerated) return;\r\n    if (type === \"long\" && this.longFillerGenerated) return;\r\n\r\n    // Mark as generated immediately to prevent race conditions\r\n    if (type === \"short\") {\r\n      this.shortFillerGenerated = true;\r\n    } else {\r\n      this.longFillerGenerated = true;\r\n    }\r\n\r\n    this.inFlight++;\r\n\r\n    let fillerText: string;\r\n\r\n    // Try LLM generation if configured\r\n    if (this.config.llmApiUrl && this.config.llmApiKey) {\r\n      try {\r\n        fillerText = await this.generateFillerWithLLM(type);\r\n        console.log(\r\n          `[FillerManager] LLM generated ${type} filler: \"${fillerText}\"`\r\n        );\r\n      } catch (error) {\r\n        console.error(`[FillerManager] LLM failed, using fallback:`, error);\r\n        fillerText =\r\n          type === \"short\"\r\n            ? this.config.shortFillerFallback\r\n            : this.config.longFillerFallback;\r\n      }\r\n    } else {\r\n      // Use fallback text\r\n      fillerText =\r\n        type === \"short\"\r\n          ? this.config.shortFillerFallback\r\n          : this.config.longFillerFallback;\r\n      console.log(\r\n        `[FillerManager] Using fallback ${type} filler: \"${fillerText}\"`\r\n      );\r\n    }\r\n\r\n    // Store generated filler\r\n    if (type === \"short\") {\r\n      this.shortFiller = fillerText;\r\n    } else {\r\n      this.longFiller = fillerText;\r\n    }\r\n\r\n    // Notify consumer\r\n    this.config.onFillerGenerated?.(type, fillerText);\r\n\r\n    // Synthesize and queue audio\r\n    try {\r\n      if (this.config.synthesize) {\r\n        // Use custom synthesizer if provided\r\n        const result = await this.config.synthesize(fillerText);\r\n        sharedAudioPlayer.addAudioIntoQueue(result.audio, result.sampleRate);\r\n      } else if (this.ttsLogic) {\r\n        // Use internal TTSLogic's synthesizeAndAddToQueue\r\n        if (this.ttsInitPromise) await this.ttsInitPromise;\r\n        await this.ttsLogic.synthesizeAndAddToQueue(fillerText);\r\n      } else {\r\n        console.warn(\"[FillerManager] No TTS available for filler synthesis\");\r\n      }\r\n      console.log(`[FillerManager] ${type} filler queued for playback`);\r\n    } catch (error) {\r\n      console.error(\r\n        `[FillerManager] Failed to synthesize ${type} filler:`,\r\n        error\r\n      );\r\n    }\r\n\r\n    this.inFlight--;\r\n  }\r\n\r\n  private async generateFillerWithLLM(type: \"short\" | \"long\"): Promise<string> {\r\n    const systemPrompt =\r\n      type === \"short\"\r\n        ? this.config.shortFillerPrompt\r\n        : this.config.longFillerPrompt;\r\n\r\n    const userMessage = [\r\n      `Language: ${this.config.languageHint}`,\r\n      \"\",\r\n      \"Current user speech (partial):\",\r\n      `\"${this.currentPartialTranscript || \"(no transcript yet)\"}\"`,\r\n      \"\",\r\n      this.shortFiller\r\n        ? `Previous short filler already generated: \"${this.shortFiller}\"`\r\n        : \"\",\r\n      \"\",\r\n      \"Output only your natural brief reaction.\",\r\n    ]\r\n      .filter(Boolean)\r\n      .join(\"\\n\");\r\n\r\n    const controller = new AbortController();\r\n    const timeout = setTimeout(\r\n      () => controller.abort(),\r\n      this.config.llmTimeoutMs\r\n    );\r\n\r\n    try {\r\n      const response = await fetch(this.config.llmApiUrl!, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n          Authorization: `Bearer ${this.config.llmApiKey}`,\r\n        },\r\n        body: JSON.stringify({\r\n          model: this.config.llmModel,\r\n          messages: [\r\n            { role: \"system\", content: systemPrompt },\r\n            { role: \"user\", content: userMessage },\r\n          ],\r\n          stream: false,\r\n        }),\r\n        signal: controller.signal,\r\n      });\r\n\r\n      clearTimeout(timeout);\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`LLM API error: ${response.status}`);\r\n      }\r\n\r\n      const data = await response.json();\r\n      const content = data.choices?.[0]?.message?.content || \"\";\r\n      return content.trim().slice(0, 100) || this.getFallback(type);\r\n    } catch (error) {\r\n      clearTimeout(timeout);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private getFallback(type: \"short\" | \"long\"): string {\r\n    return type === \"short\"\r\n      ? this.config.shortFillerFallback\r\n      : this.config.longFillerFallback;\r\n  }\r\n\r\n  /**\r\n   * Manually trigger a filler (useful for testing)\r\n   */\r\n  async triggerFiller(type: \"short\" | \"long\"): Promise<void> {\r\n    await this.generateFiller(type);\r\n  }\r\n\r\n  /**\r\n   * Reset state for new session\r\n   */\r\n  reset(): void {\r\n    this.clearTimers();\r\n    this.speechStartedAt = 0;\r\n    this.shortFillerGenerated = false;\r\n    this.longFillerGenerated = false;\r\n    this.shortFiller = null;\r\n    this.longFiller = null;\r\n    this.currentPartialTranscript = \"\";\r\n  }\r\n\r\n  /**\r\n   * Cleanup\r\n   */\r\n  destroy(): void {\r\n    this.clearTimers();\r\n    if (this.unsubscribe) {\r\n      this.unsubscribe();\r\n    }\r\n  }\r\n}\r\n\r\n// Singleton instance for internal use\r\nlet fillerManagerInstance: FillerManager | null = null;\r\n\r\nexport function getFillerManager(): FillerManager {\r\n  if (!fillerManagerInstance) {\r\n    fillerManagerInstance = new FillerManager();\r\n  }\r\n  return fillerManagerInstance;\r\n}\r\n\r\nexport function configureFillerManager(config: FillerConfig): FillerManager {\r\n  const manager = getFillerManager();\r\n  manager.configure(config);\r\n  return manager;\r\n}\r\n","/**\r\n * stt-tts-lib - Speech-to-Text and Text-to-Speech Library\r\n * Copyright (C) 2026 Navgurukul\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\nimport { internalSpeechState } from \"../internal/speech-state\";\r\nimport { FillerManager, FillerConfig } from \"../tts/filler-manager\";\r\n\r\n// Public callback/type aliases kept for backward compatibility with STTLogic API\r\nexport type WordUpdateCallback = (words: string[]) => void;\r\nexport type MicTimeUpdateCallback = (ms: number) => void;\r\nexport type RestartMetricsCallback = (\r\n  count: number,\r\n  lastDuration: number | null\r\n) => void;\r\nexport type VadCallbacks = {\r\n  onSpeechStart?: () => void;\r\n  onSpeechEnd?: () => void;\r\n};\r\n\r\ntype LogCallback = (\r\n  message: string,\r\n  type?: \"info\" | \"error\" | \"warning\"\r\n) => void;\r\ntype TranscriptCallback = (transcript: string) => void;\r\n\r\ninterface SpeechRecognitionEvent extends Event {\r\n  results: SpeechRecognitionResultList;\r\n  resultIndex: number;\r\n}\r\n\r\ninterface SpeechRecognitionErrorEvent extends Event {\r\n  error: string;\r\n}\r\n\r\nexport interface ResetSTTOptions {\r\n  sessionDurationMs?: number;\r\n  interimSaveIntervalMs?: number;\r\n  preserveTranscriptOnStart?: boolean;\r\n\r\n  // Filler word configuration\r\n  /** Enable short filler (default: false) */\r\n  enableShortFiller?: boolean;\r\n  /** Enable long filler (default: false) */\r\n  enableLongFiller?: boolean;\r\n  /** Delay before short filler in ms (default: 5000) */\r\n  shortFillerDelayMs?: number;\r\n  /** Delay before long filler in ms (default: 10000) */\r\n  longFillerDelayMs?: number;\r\n  /** Fallback short filler if LLM fails */\r\n  shortFillerFallback?: string;\r\n  /** Fallback long filler if LLM fails */\r\n  longFillerFallback?: string;\r\n  /** Callback when filler is generated */\r\n  onFillerGenerated?: (type: \"short\" | \"long\", text: string) => void;\r\n\r\n  // LLM Configuration for dynamic fillers\r\n  /** LLM API URL (required for dynamic filler generation) */\r\n  llmApiUrl?: string;\r\n  /** LLM API Key */\r\n  llmApiKey?: string;\r\n  /** LLM Model name (default: \"deepseek-chat\") */\r\n  llmModel?: string;\r\n  /** LLM request timeout in ms (default: 3000) */\r\n  llmTimeoutMs?: number;\r\n  /** Language hint for LLM (e.g., \"English\", \"Hindi\") */\r\n  languageHint?: string;\r\n}\r\n\r\n// Alias to match previous public surface\r\nexport type STTLogicOptions = ResetSTTOptions;\r\n\r\nexport class ResetSTTLogic {\r\n  private recognition: any;\r\n  private isListening: boolean = false;\r\n  private fullTranscript: string = \"\";\r\n  private heardWords: string[] = [];\r\n  private onLog: LogCallback;\r\n  private onTranscript: TranscriptCallback;\r\n  private onWordsUpdate: WordUpdateCallback | null = null;\r\n  private onMicTimeUpdate: MicTimeUpdateCallback | null = null;\r\n  private onRestartMetrics: RestartMetricsCallback | null = null;\r\n  private options: {\r\n    sessionDurationMs: number;\r\n    interimSaveIntervalMs: number;\r\n    preserveTranscriptOnStart: boolean;\r\n  };\r\n\r\n  private micOnTime: number = 0;\r\n  private sessionDuration: number = 30000;\r\n  private lastTickTime: number = 0;\r\n  private micTimeInterval: number | null = null;\r\n  private restartCount: number = 0;\r\n  private isRestarting: boolean = false;\r\n  private isRecognitionRunning: boolean = false;\r\n  private lastInterimTranscript: string = \"\";\r\n  private lastInterimSaveTime: number = 0;\r\n  private interimSaveInterval: number = 1000;\r\n  private lastInterimResultTime: number = 0;\r\n  private lastSavedLength: number = 0;\r\n  private transcriptBeforeRestart: string = \"\";\r\n  private sessionStartTranscript: string = \"\";\r\n  private resultHandler?: (e: Event) => void;\r\n  private errorHandler?: (e: Event) => void;\r\n  private endHandler?: (e?: Event) => void;\r\n  private startHandler?: (e?: Event) => void;\r\n  private sessionId: number = 0;\r\n  private awaitingRestartFirstResultId: number | null = null;\r\n  private lastWasFinal: boolean = false;\r\n  private restartMetrics: Record<\r\n    number,\r\n    {\r\n      requestedAt: number;\r\n      stopAt?: number;\r\n      startAttemptAt?: number;\r\n      startedAt?: number;\r\n      firstResultAt?: number;\r\n    }\r\n  > = {};\r\n  private isAutoRestarting: boolean = false;\r\n  private onUserSpeechStart?: () => void;\r\n  private onUserSpeechEnd?: () => void;\r\n  private fillerManager: FillerManager | null = null;\r\n\r\n  constructor(\r\n    onLog: LogCallback,\r\n    onTranscript: TranscriptCallback,\r\n    options: ResetSTTOptions = {}\r\n  ) {\r\n    this.onLog = onLog;\r\n    this.onTranscript = onTranscript;\r\n    this.options = {\r\n      sessionDurationMs: options.sessionDurationMs ?? 30000,\r\n      interimSaveIntervalMs: options.interimSaveIntervalMs ?? 5000,\r\n      preserveTranscriptOnStart: options.preserveTranscriptOnStart ?? false,\r\n    };\r\n    this.sessionDuration = this.options.sessionDurationMs;\r\n    this.interimSaveInterval = this.options.interimSaveIntervalMs;\r\n\r\n    // Initialize filler manager if any filler is enabled\r\n    if (options.enableShortFiller || options.enableLongFiller) {\r\n      this.fillerManager = new FillerManager({\r\n        enableShortFiller: options.enableShortFiller,\r\n        enableLongFiller: options.enableLongFiller,\r\n        shortFillerDelayMs: options.shortFillerDelayMs,\r\n        longFillerDelayMs: options.longFillerDelayMs,\r\n        shortFillerFallback: options.shortFillerFallback,\r\n        longFillerFallback: options.longFillerFallback,\r\n        // LLM configuration for dynamic filler generation\r\n        llmApiUrl: options.llmApiUrl,\r\n        llmApiKey: options.llmApiKey,\r\n        llmModel: options.llmModel,\r\n        llmTimeoutMs: options.llmTimeoutMs,\r\n        languageHint: options.languageHint,\r\n        onFillerGenerated: options.onFillerGenerated,\r\n      });\r\n      this.onLog(\r\n        `[STTLogic] Filler manager initialized (short: ${\r\n          options.enableShortFiller\r\n        }, long: ${options.enableLongFiller}, LLM: ${\r\n          options.llmApiUrl ? \"configured\" : \"disabled\"\r\n        })`,\r\n        \"info\"\r\n      );\r\n    }\r\n\r\n    const SpeechRecognitionAPI =\r\n      (window as any).SpeechRecognition ||\r\n      (window as any).webkitSpeechRecognition;\r\n\r\n    if (!SpeechRecognitionAPI) {\r\n      this.onLog(\"Speech Recognition API not supported\", \"error\");\r\n      throw new Error(\"Speech Recognition API not available\");\r\n    }\r\n\r\n    this.recognition = new SpeechRecognitionAPI();\r\n    this.setupRecognition();\r\n  }\r\n\r\n  public setWordsUpdateCallback(callback: WordUpdateCallback): void {\r\n    this.onWordsUpdate = callback;\r\n  }\r\n\r\n  public setMicTimeUpdateCallback(callback: MicTimeUpdateCallback): void {\r\n    this.onMicTimeUpdate = callback;\r\n  }\r\n\r\n  public setRestartMetricsCallback(callback: RestartMetricsCallback): void {\r\n    this.onRestartMetrics = callback;\r\n  }\r\n\r\n  public setVadCallbacks(\r\n    onSpeechStart?: () => void,\r\n    onSpeechEnd?: () => void\r\n  ): void {\r\n    this.onUserSpeechStart = onSpeechStart || undefined;\r\n    this.onUserSpeechEnd = onSpeechEnd || undefined;\r\n  }\r\n\r\n  public getSessionDurationMs(): number {\r\n    return this.sessionDuration;\r\n  }\r\n\r\n  public isInAutoRestart(): boolean {\r\n    return this.isAutoRestarting;\r\n  }\r\n\r\n  public getFullTranscript(): string {\r\n    if (this.transcriptBeforeRestart.length > 0) {\r\n      if (this.fullTranscript.length > 0) {\r\n        return (\r\n          this.transcriptBeforeRestart +\r\n          \" \" +\r\n          this.fullTranscript\r\n        ).trim();\r\n      }\r\n      return this.transcriptBeforeRestart;\r\n    }\r\n    return this.fullTranscript;\r\n  }\r\n\r\n  public clearTranscript(): void {\r\n    this.fullTranscript = \"\";\r\n    this.transcriptBeforeRestart = \"\";\r\n    this.sessionStartTranscript = \"\";\r\n    this.heardWords = [];\r\n  }\r\n\r\n  private setupRecognition(): void {\r\n    this.recognition.lang = \"en-US\";\r\n    this.recognition.interimResults = true;\r\n    this.recognition.continuous = true;\r\n    (this.recognition as any).maxAlternatives = 1;\r\n\r\n    this.resultHandler = (event: Event) => {\r\n      const speechEvent = event as SpeechRecognitionEvent;\r\n      let completeTranscript = \"\";\r\n      for (let i = 0; i < speechEvent.results.length; i++) {\r\n        completeTranscript += speechEvent.results[i][0].transcript + \" \";\r\n      }\r\n      completeTranscript = completeTranscript.trim();\r\n\r\n      const isFinal =\r\n        speechEvent.results[speechEvent.results.length - 1].isFinal;\r\n\r\n      completeTranscript = this.collapseRepeats(completeTranscript);\r\n      this.lastInterimTranscript = completeTranscript;\r\n      this.lastInterimResultTime = Date.now();\r\n\r\n      // Update filler manager with current partial transcript\r\n      if (this.fillerManager && !isFinal) {\r\n        this.fillerManager.updatePartialTranscript(completeTranscript);\r\n      }\r\n\r\n      if (this.awaitingRestartFirstResultId != null) {\r\n        const rid = this.awaitingRestartFirstResultId;\r\n        if (\r\n          this.restartMetrics[rid] &&\r\n          !this.restartMetrics[rid].firstResultAt\r\n        ) {\r\n          this.restartMetrics[rid].firstResultAt = Date.now();\r\n          const delta =\r\n            this.restartMetrics[rid].firstResultAt -\r\n            this.restartMetrics[rid].requestedAt;\r\n          this.onLog(\r\n            ` First result after restart #${rid} in ${delta}ms`,\r\n            \"info\"\r\n          );\r\n          this.awaitingRestartFirstResultId = null;\r\n        }\r\n      }\r\n      this.onLog(\r\n        `[${isFinal ? \"FINAL\" : \"INTERIM\"}] \"${completeTranscript}\"`,\r\n        isFinal ? \"info\" : \"warning\"\r\n      );\r\n\r\n      if (!isFinal && this.lastWasFinal) {\r\n        // User started speaking - notify internal speech state\r\n        internalSpeechState.setSpeaking(true);\r\n        try {\r\n          this.onUserSpeechStart?.();\r\n        } catch {}\r\n      }\r\n\r\n      this.lastWasFinal = isFinal;\r\n\r\n      if (isFinal) {\r\n        // User stopped speaking - notify internal speech state\r\n        internalSpeechState.setSpeaking(false);\r\n        try {\r\n          this.onUserSpeechEnd?.();\r\n        } catch {}\r\n\r\n        this.fullTranscript = (\r\n          this.sessionStartTranscript +\r\n          \" \" +\r\n          completeTranscript\r\n        ).trim();\r\n        this.fullTranscript = this.collapseRepeats(this.fullTranscript);\r\n\r\n        this.heardWords = this.fullTranscript\r\n          .split(/\\s+/)\r\n          .filter((word) => word.length > 0);\r\n\r\n        this.onTranscript(this.getFullTranscript());\r\n        this.lastSavedLength = this.fullTranscript.length;\r\n        if (this.onWordsUpdate) this.onWordsUpdate(this.heardWords);\r\n\r\n        this.lastInterimTranscript = \"\";\r\n\r\n        if (this.awaitingRestartFirstResultId != null) {\r\n          const rid = this.awaitingRestartFirstResultId;\r\n          if (\r\n            this.restartMetrics[rid] &&\r\n            !this.restartMetrics[rid].firstResultAt\r\n          ) {\r\n            this.restartMetrics[rid].firstResultAt = Date.now();\r\n            const startedAt =\r\n              this.restartMetrics[rid].startedAt ||\r\n              this.restartMetrics[rid].startAttemptAt ||\r\n              Date.now();\r\n            const firstResultDelta =\r\n              this.restartMetrics[rid].firstResultAt -\r\n              this.restartMetrics[rid].requestedAt;\r\n            this.onLog(\r\n              ` First result after restart #${rid} in ${firstResultDelta}ms`,\r\n              \"info\"\r\n            );\r\n            this.awaitingRestartFirstResultId = null;\r\n          }\r\n        }\r\n      }\r\n    };\r\n    this.recognition.addEventListener(\"result\", this.resultHandler);\r\n\r\n    this.errorHandler = (event: Event) => {\r\n      const errorEvent = event as SpeechRecognitionErrorEvent;\r\n      if (errorEvent.error === \"aborted\" && this.isRestarting) {\r\n        this.onLog(\"Aborted during restart (ignored)\", \"info\");\r\n        this.isRecognitionRunning = false;\r\n        return;\r\n      }\r\n      this.onLog(`Error: ${errorEvent.error}`, \"error\");\r\n      if (\r\n        errorEvent.error === \"no-speech\" ||\r\n        errorEvent.error === \"audio-capture\" ||\r\n        errorEvent.error === \"network\"\r\n      ) {\r\n        setTimeout(() => {\r\n          if (\r\n            this.isListening &&\r\n            !this.isRestarting &&\r\n            !this.isRecognitionRunning\r\n          ) {\r\n            try {\r\n              this.recognition.start();\r\n              this.isRecognitionRunning = true;\r\n              this.sessionId++;\r\n            } catch (e) {\r\n              this.onLog(`Failed restart after error: ${e}`, \"error\");\r\n            }\r\n          }\r\n        }, 500);\r\n      } else {\r\n        this.onLog(\r\n          `Unhandled SpeechRecognition error: ${errorEvent.error}`,\r\n          \"warning\"\r\n        );\r\n      }\r\n    };\r\n    this.recognition.addEventListener(\"error\", this.errorHandler);\r\n\r\n    this.endHandler = () => {\r\n      this.isRecognitionRunning = false;\r\n      if (this.isListening && !this.isRestarting) {\r\n        setTimeout(() => {\r\n          if (this.isListening && !this.isRestarting) {\r\n            try {\r\n              this.recognition.start();\r\n              this.isRecognitionRunning = true;\r\n              this.sessionId++;\r\n              this.onLog(\r\n                ` Auto-resumed recognition after end (session ${this.sessionId})`,\r\n                \"info\"\r\n              );\r\n            } catch (e) {\r\n              this.onLog(`Failed to auto-start after end: ${e}`, \"error\");\r\n            }\r\n          }\r\n        }, 100);\r\n      }\r\n    };\r\n    this.recognition.addEventListener(\"end\", this.endHandler);\r\n\r\n    this.startHandler = () => {\r\n      this.isRecognitionRunning = true;\r\n      const rid = this.awaitingRestartFirstResultId;\r\n      if (rid != null && this.restartMetrics[rid]) {\r\n        if (!this.restartMetrics[rid].startedAt) {\r\n          this.restartMetrics[rid].startedAt = Date.now();\r\n          this.onLog(\r\n            ` Restart #${rid} recognition started in ${\r\n              this.restartMetrics[rid].startedAt -\r\n              this.restartMetrics[rid].requestedAt\r\n            }ms`,\r\n            \"info\"\r\n          );\r\n        }\r\n      }\r\n    };\r\n    this.recognition.addEventListener(\"start\", this.startHandler);\r\n  }\r\n\r\n  private waitForEventOnce(\r\n    eventName: string,\r\n    timeoutMs: number\r\n  ): Promise<Event | null> {\r\n    return new Promise((resolve) => {\r\n      let timer: number | null = null;\r\n      const handler = (ev: Event) => {\r\n        if (timer !== null) clearTimeout(timer);\r\n        this.recognition.removeEventListener(eventName, handler);\r\n        resolve(ev);\r\n      };\r\n      this.recognition.addEventListener(eventName, handler);\r\n      timer = window.setTimeout(() => {\r\n        this.recognition.removeEventListener(eventName, handler);\r\n        resolve(null);\r\n      }, timeoutMs);\r\n    });\r\n  }\r\n\r\n  private startMicTimer(): void {\r\n    this.lastTickTime = Date.now();\r\n    this.lastInterimSaveTime = Date.now();\r\n\r\n    this.micTimeInterval = window.setInterval(() => {\r\n      if (this.isListening) {\r\n        const now = Date.now();\r\n        const elapsed = now - this.lastTickTime;\r\n        this.micOnTime += elapsed;\r\n        this.lastTickTime = now;\r\n\r\n        if (now - this.lastInterimSaveTime >= this.interimSaveInterval) {\r\n          this.saveInterimToFinal();\r\n          this.lastInterimSaveTime = now;\r\n        }\r\n\r\n        if (this.micOnTime >= this.sessionDuration) {\r\n          if (!this.isRestarting) this.performRestart();\r\n        }\r\n        if (this.onMicTimeUpdate) this.onMicTimeUpdate(this.micOnTime);\r\n      }\r\n    }, 100);\r\n  }\r\n\r\n  private stopMicTimer(): void {\r\n    if (this.micTimeInterval) {\r\n      clearInterval(this.micTimeInterval);\r\n      this.micTimeInterval = null;\r\n    }\r\n  }\r\n\r\n  private saveInterimToFinal(): void {\r\n    if (!this.lastInterimTranscript) return;\r\n    const now = Date.now();\r\n    if (\r\n      now - this.lastInterimResultTime > this.interimSaveInterval &&\r\n      this.lastInterimTranscript.length > this.lastSavedLength\r\n    ) {\r\n      this.fullTranscript = (\r\n        this.fullTranscript +\r\n        \" \" +\r\n        this.lastInterimTranscript\r\n      ).trim();\r\n      this.fullTranscript = this.collapseRepeats(this.fullTranscript);\r\n      this.lastSavedLength = this.fullTranscript.length;\r\n      if (this.onWordsUpdate) {\r\n        const words = this.fullTranscript\r\n          .split(/\\s+/)\r\n          .filter((w) => w.length > 0);\r\n        this.onWordsUpdate(words);\r\n      }\r\n      this.onTranscript(this.getFullTranscript());\r\n    }\r\n  }\r\n\r\n  private getSuffixToAppend(base: string, current: string): string {\r\n    if (!base || base.length === 0) return current;\r\n    if (!current || current.length === 0) return \"\";\r\n    base = base.trim();\r\n    current = current.trim();\r\n    if (current.startsWith(base)) {\r\n      return current.slice(base.length).trim();\r\n    }\r\n    const maxOverlap = Math.min(base.length, current.length);\r\n    for (let overlap = maxOverlap; overlap > 0; overlap--) {\r\n      if (base.endsWith(current.slice(0, overlap))) {\r\n        return current.slice(overlap).trim();\r\n      }\r\n    }\r\n    return current;\r\n  }\r\n\r\n  private collapseRepeats(text: string): string {\r\n    if (!text || text.trim().length === 0) return text.trim();\r\n    let normalized = text.replace(/\\s+/g, \" \").trim();\r\n    const n = normalized.length;\r\n    const lps: number[] = new Array(n).fill(0);\r\n    for (let i = 1; i < n; i++) {\r\n      let j = lps[i - 1];\r\n      while (j > 0 && normalized[i] !== normalized[j]) j = lps[j - 1];\r\n      if (normalized[i] === normalized[j]) j++;\r\n      lps[i] = j;\r\n    }\r\n    const period = n - lps[n - 1];\r\n    if (period < n && n % period === 0) {\r\n      return normalized.slice(0, period).trim();\r\n    }\r\n    const words = normalized.split(\" \");\r\n    for (\r\n      let block = Math.min(20, Math.floor(words.length / 2));\r\n      block >= 1;\r\n      block--\r\n    ) {\r\n      let i = 0;\r\n      while (i + 2 * block <= words.length) {\r\n        let blockA = words.slice(i, i + block).join(\" \");\r\n        let blockB = words.slice(i + block, i + 2 * block).join(\" \");\r\n        if (blockA === blockB) {\r\n          words.splice(i + block, block);\r\n        } else {\r\n          i++;\r\n        }\r\n      }\r\n    }\r\n    const collapsedWords: string[] = [];\r\n    for (const w of words) {\r\n      if (\r\n        collapsedWords.length === 0 ||\r\n        collapsedWords[collapsedWords.length - 1] !== w\r\n      )\r\n        collapsedWords.push(w);\r\n    }\r\n    return collapsedWords.join(\" \").trim();\r\n  }\r\n\r\n  private performRestart(): void {\r\n    if (!this.isListening || this.isRestarting) return;\r\n\r\n    const restartStartTime = Date.now();\r\n    this.restartCount++;\r\n    this.isRestarting = true;\r\n    this.isAutoRestarting = true;\r\n    const rid = ++this.sessionId;\r\n    this.awaitingRestartFirstResultId = rid;\r\n    this.restartMetrics[rid] = { requestedAt: restartStartTime };\r\n\r\n    this.onLog(\r\n      ` [AUTO-RESTART] Session ${rid} - buffering transcript, waiting for silence...`,\r\n      \"warning\"\r\n    );\r\n\r\n    if (this.lastInterimTranscript.trim().length > 0) {\r\n      this.saveInterimToFinal();\r\n    }\r\n\r\n    this.transcriptBeforeRestart = this.getFullTranscript();\r\n    this.fullTranscript = \"\";\r\n    this.sessionStartTranscript = \"\";\r\n    this.lastInterimTranscript = \"\";\r\n    this.heardWords = [];\r\n\r\n    this.stopMicTimer();\r\n\r\n    const stopTimeout = 600;\r\n    const startTimeout = 1000;\r\n    const firstResultTimeout = 2000;\r\n\r\n    const stopNow = async () => {\r\n      try {\r\n        if (this.isRecognitionRunning) {\r\n          this.recognition.stop();\r\n        } else {\r\n          this.onLog(\"Recognition not running at stop attempt\", \"warning\");\r\n        }\r\n      } catch (err) {\r\n        this.onLog(`Stop threw: ${err}`, \"warning\");\r\n      }\r\n      const endEvent = await this.waitForEventOnce(\"end\", stopTimeout);\r\n      if (!endEvent) {\r\n        try {\r\n          (this.recognition as any).abort();\r\n        } catch (err) {\r\n          this.onLog(`Abort also failed: ${err}`, \"error\");\r\n        }\r\n        await this.waitForEventOnce(\"end\", 300);\r\n      }\r\n      this.restartMetrics[rid].stopAt = Date.now();\r\n    };\r\n\r\n    (async () => {\r\n      await stopNow();\r\n      this.restartMetrics[rid].startAttemptAt = Date.now();\r\n      try {\r\n        if (!this.isRecognitionRunning) {\r\n          this.sessionId = rid;\r\n          this.recognition.start();\r\n        } else {\r\n          this.onLog(\r\n            \"Recognition already running at restart time; skipping start.\",\r\n            \"warning\"\r\n          );\r\n        }\r\n      } catch (e) {\r\n        this.onLog(`Failed to start recognition after restart: ${e}`, \"error\");\r\n      }\r\n\r\n      const startEv = await this.waitForEventOnce(\"start\", startTimeout);\r\n      if (startEv) {\r\n        this.restartMetrics[rid].startedAt = Date.now();\r\n      } else {\r\n        this.onLog(\r\n          `Restart #${rid} did not produce start event within ${startTimeout}ms`,\r\n          \"warning\"\r\n        );\r\n      }\r\n\r\n      const resEv = await this.waitForEventOnce(\"result\", firstResultTimeout);\r\n      if (resEv) {\r\n        if (this.restartMetrics[rid])\r\n          this.restartMetrics[rid].firstResultAt = Date.now();\r\n        const firstResultDelta =\r\n          (this.restartMetrics[rid].firstResultAt || Date.now()) -\r\n          (this.restartMetrics[rid].requestedAt || Date.now());\r\n        this.onLog(\r\n          ` First result after restart #${rid} in ${firstResultDelta}ms`,\r\n          \"info\"\r\n        );\r\n      } else {\r\n        this.onLog(\r\n          `Restart #${rid} produced no result within ${firstResultTimeout}ms`,\r\n          \"warning\"\r\n        );\r\n      }\r\n\r\n      const startedAt =\r\n        this.restartMetrics[rid].startedAt ||\r\n        this.restartMetrics[rid].startAttemptAt ||\r\n        Date.now();\r\n      const restartDuration = startedAt - this.restartMetrics[rid].requestedAt;\r\n      if (this.onRestartMetrics)\r\n        this.onRestartMetrics(this.restartCount, restartDuration);\r\n      this.onLog(\r\n        ` Session ${rid} restarted in ${restartDuration}ms - resuming from silence gate`,\r\n        \"info\"\r\n      );\r\n      this.startMicTimer();\r\n      this.isRestarting = false;\r\n      this.isAutoRestarting = false;\r\n    })();\r\n  }\r\n\r\n  public start(): void {\r\n    if (this.isListening) return;\r\n\r\n    try {\r\n      this.isListening = true;\r\n      if (!this.options.preserveTranscriptOnStart) {\r\n        this.fullTranscript = \"\";\r\n        this.heardWords = [];\r\n        this.transcriptBeforeRestart = \"\";\r\n        this.sessionStartTranscript = \"\";\r\n      } else {\r\n        this.sessionStartTranscript = this.fullTranscript;\r\n      }\r\n\r\n      this.micOnTime = 0;\r\n      this.restartCount = 0;\r\n      this.lastSavedLength = 0;\r\n      this.lastInterimTranscript = \"\";\r\n      this.lastWasFinal = false;\r\n\r\n      if (!this.isRecognitionRunning) {\r\n        this.sessionId++;\r\n        this.recognition.start();\r\n        this.isRecognitionRunning = true;\r\n      }\r\n      this.startMicTimer();\r\n      this.onLog(\r\n        \"Listening started (auto-restart every 30s of mic time)\",\r\n        \"info\"\r\n      );\r\n    } catch (error) {\r\n      this.isListening = false;\r\n      this.onLog(`Failed to start: ${error}`, \"error\");\r\n    }\r\n  }\r\n\r\n  public stop(): void {\r\n    if (!this.isListening) return;\r\n\r\n    try {\r\n      this.isListening = false;\r\n      this.isAutoRestarting = false;\r\n      this.stopMicTimer();\r\n      this.recognition.stop();\r\n      this.isRecognitionRunning = false;\r\n      this.onLog(\r\n        `Stopped listening (total mic time: ${(this.micOnTime / 1000).toFixed(\r\n          1\r\n        )}s, restarts: ${this.restartCount})`,\r\n        \"info\"\r\n      );\r\n    } catch (error) {\r\n      this.onLog(`Failed to stop: ${error}`, \"error\");\r\n    }\r\n  }\r\n\r\n  public destroy(): void {\r\n    this.isListening = false;\r\n    this.stopMicTimer();\r\n\r\n    // Cleanup filler manager\r\n    if (this.fillerManager) {\r\n      this.fillerManager.destroy();\r\n      this.fillerManager = null;\r\n    }\r\n\r\n    try {\r\n      (this.recognition as any).abort?.();\r\n    } catch (e) {}\r\n    try {\r\n      if (this.resultHandler)\r\n        this.recognition.removeEventListener(\"result\", this.resultHandler);\r\n      if (this.errorHandler)\r\n        this.recognition.removeEventListener(\"error\", this.errorHandler);\r\n      if (this.endHandler)\r\n        this.recognition.removeEventListener(\r\n          \"end\",\r\n          this.endHandler as EventListener\r\n        );\r\n      if (this.startHandler)\r\n        this.recognition.removeEventListener(\r\n          \"start\",\r\n          this.startHandler as EventListener\r\n        );\r\n    } catch (e) {}\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Filler Manager Methods\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Get the filler manager instance (if enabled)\r\n   */\r\n  getFillerManager(): FillerManager | null {\r\n    return this.fillerManager;\r\n  }\r\n\r\n  /**\r\n   * Set a custom synthesizer for filler audio generation.\r\n   * Optional - internal TTS is used by default.\r\n   */\r\n  setFillerSynthesizer(\r\n    synthesize: (\r\n      text: string\r\n    ) => Promise<{ audio: Float32Array; sampleRate: number }>\r\n  ): void {\r\n    if (this.fillerManager) {\r\n      this.fillerManager.setSynthesizer(synthesize);\r\n      this.onLog(\"[STTLogic] Custom filler synthesizer configured\", \"info\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the generated short filler text (null if not generated yet)\r\n   */\r\n  getShortFiller(): string | null {\r\n    return this.fillerManager?.shortFiller ?? null;\r\n  }\r\n\r\n  /**\r\n   * Get the generated long filler text (null if not generated yet)\r\n   */\r\n  getLongFiller(): string | null {\r\n    return this.fillerManager?.longFiller ?? null;\r\n  }\r\n}\r\n\r\n// Backward-compatible alias so consumers can import STTLogic as before\r\nexport class STTLogic extends ResetSTTLogic {}\r\n","/**\r\n * stt-tts-lib - Speech-to-Text and Text-to-Speech Library\r\n * Copyright (C) 2026 Navgurukul\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\nexport interface PiperVoiceConfig {\r\n  voiceId: string;\r\n  modelPath?: string;\r\n  sampleRate?: number;\r\n  lengthScale?: number;\r\n  noiseScale?: number;\r\n  speaker?: string;\r\n}\r\n\r\nexport interface PreparedPiperVoice {\r\n  voiceId: string;\r\n  modelPath: string;\r\n  sampleRate: number;\r\n  inference: {\r\n    lengthScale: number;\r\n    noiseScale: number;\r\n  };\r\n  metadata: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Normalize Piper voice configuration so downstream synthesis gets predictable defaults.\r\n */\r\nexport function preparePiperVoice(config: PiperVoiceConfig): PreparedPiperVoice {\r\n  const modelPath = config.modelPath ?? `voices/${config.voiceId}.onnx`;\r\n\r\n  return {\r\n    voiceId: config.voiceId,\r\n    modelPath,\r\n    sampleRate: config.sampleRate ?? 22050,\r\n    inference: {\r\n      lengthScale: config.lengthScale ?? 1.0,\r\n      noiseScale: config.noiseScale ?? 0.667,\r\n    },\r\n    metadata: {\r\n      speaker: config.speaker ?? \"default\",\r\n    },\r\n  };\r\n}\r\n","/**\r\n * stt-tts-lib - Speech-to-Text and Text-to-Speech Library\r\n * Copyright (C) 2026 Navgurukul\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\nexport interface StreamTokensOptions {\r\n  chunkSize?: number;\r\n  delayMs?: number;\r\n  onChunk?: (text: string) => Promise<void> | void;\r\n}\r\n\r\nexport interface StreamTokensResult {\r\n  chunksEmitted: number;\r\n  characters: number;\r\n}\r\n\r\nfunction isAsyncIterable<T>(value: AsyncIterable<T> | Iterable<T>): value is AsyncIterable<T> {\r\n  return typeof (value as AsyncIterable<T>)[Symbol.asyncIterator] === \"function\";\r\n}\r\n\r\nconst sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\r\n\r\n/**\r\n * Convert incremental tokens to speech-sized chunks. Consumers can bridge this into an audio renderer.\r\n */\r\nexport async function streamTokensToSpeech(\r\n  tokens: AsyncIterable<string> | Iterable<string>,\r\n  options: StreamTokensOptions = {},\r\n): Promise<StreamTokensResult> {\r\n  const chunkSize = options.chunkSize ?? 40;\r\n  const delayMs = options.delayMs ?? 0;\r\n\r\n  let buffer = \"\";\r\n  let chunksEmitted = 0;\r\n  let characters = 0;\r\n\r\n  const emit = async () => {\r\n    if (!buffer) return;\r\n    characters += buffer.length;\r\n    chunksEmitted += 1;\r\n    if (options.onChunk) {\r\n      await options.onChunk(buffer);\r\n    }\r\n    buffer = \"\";\r\n    if (delayMs > 0) {\r\n      await sleep(delayMs);\r\n    }\r\n  };\r\n\r\n  if (isAsyncIterable(tokens)) {\r\n    for await (const token of tokens) {\r\n      buffer += token;\r\n      if (buffer.length >= chunkSize) {\r\n        await emit();\r\n      }\r\n    }\r\n  } else {\r\n    for (const token of tokens) {\r\n      buffer += token;\r\n      if (buffer.length >= chunkSize) {\r\n        await emit();\r\n      }\r\n    }\r\n  }\r\n\r\n  if (buffer) {\r\n    await emit();\r\n  }\r\n\r\n  return { chunksEmitted, characters };\r\n}\r\n","/**\r\n * stt-tts-lib - Speech-to-Text and Text-to-Speech Library\r\n * Copyright (C) 2026 Navgurukul\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\nexport type OrtDevice = \"cpu\" | \"webgpu\";\r\nexport type OrtLogLevel = \"verbose\" | \"warning\" | \"error\";\r\n\r\nexport interface OrtEnvironmentConfig {\r\n  device?: OrtDevice;\r\n  logLevel?: OrtLogLevel;\r\n  providers?: string[];\r\n}\r\n\r\nexport interface OrtEnvironment {\r\n  device: OrtDevice;\r\n  logLevel: OrtLogLevel;\r\n  providers: string[];\r\n  initialized: boolean;\r\n  init: () => Promise<void>;\r\n}\r\n\r\n/**\r\n * Minimal Onnx Runtime bootstrapper. This is intentionally dependency-light: callers can pass\r\n * a custom provider list when integrating with onnxruntime-web or node-ort.\r\n */\r\nexport async function createOrtEnvironment(\r\n  config: OrtEnvironmentConfig = {},\r\n): Promise<OrtEnvironment> {\r\n  const providers = config.providers ?? (config.device === \"webgpu\" ? [\"webgpu\", \"wasm\"] : [\"wasm\"]);\r\n\r\n  const environment: OrtEnvironment = {\r\n    device: config.device ?? \"cpu\",\r\n    logLevel: config.logLevel ?? \"warning\",\r\n    providers,\r\n    initialized: false,\r\n    async init() {\r\n      // Real implementation would call into the ORT API. Here we just flip a flag for consumers.\r\n      this.initialized = true;\r\n    },\r\n  };\r\n\r\n  await environment.init();\r\n  return environment;\r\n}\r\n","/**\r\n * stt-tts-lib - Speech-to-Text and Text-to-Speech Library\r\n * Copyright (C) 2026 Navgurukul\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\nimport { createOrtEnvironment, OrtEnvironment, OrtEnvironmentConfig } from \"./ort-setup.js\";\r\nimport { preparePiperVoice, PiperVoiceConfig, PreparedPiperVoice } from \"./prepare-piper-voice.js\";\r\n\r\nexport type SynthResult = string | ArrayBuffer | Uint8Array;\r\nexport type Synthesizer = (text: string, voice: PreparedPiperVoice) => Promise<SynthResult>;\r\nexport type Player = (audio: SynthResult) => Promise<void>;\r\n\r\nconst voiceCache = new Map<string, PreparedPiperVoice>();\r\nlet ortEnv: OrtEnvironment | null = null;\r\n\r\nexport async function ensureOrtReady(config: OrtEnvironmentConfig = {}): Promise<OrtEnvironment> {\r\n  if (ortEnv) return ortEnv;\r\n  ortEnv = await createOrtEnvironment(config);\r\n  return ortEnv;\r\n}\r\n\r\nexport async function ensureVoiceLoaded(config: PiperVoiceConfig): Promise<PreparedPiperVoice> {\r\n  const cached = voiceCache.get(config.voiceId);\r\n  if (cached) return cached;\r\n  const voice = preparePiperVoice(config);\r\n  voiceCache.set(config.voiceId, voice);\r\n  return voice;\r\n}\r\n\r\nexport async function warmupPiper(\r\n  voiceConfig: PiperVoiceConfig,\r\n  synth: Synthesizer,\r\n  text = \"warmup\",\r\n): Promise<void> {\r\n  const voice = await ensureVoiceLoaded(voiceConfig);\r\n  await synth(text, voice);\r\n}\r\n\r\nexport function resetVoiceCache(): void {\r\n  voiceCache.clear();\r\n}\r\n\r\nexport function getBackendLabel(device: string | undefined): string {\r\n  if (!device) return \"auto\";\r\n  return device === \"webgpu\" ? \"WebGPU\" : \"CPU\";\r\n}\r\n\r\nexport function isCorruptModelError(error: unknown): boolean {\r\n  if (!error) return false;\r\n  const msg = typeof error === \"string\" ? error : (error as { message?: string }).message;\r\n  if (!msg) return false;\r\n  return /corrupt|checksum|integrity/i.test(msg);\r\n}\r\n\r\n// ---------------------------------------------------------------------------\r\n// Workers and helpers\r\n// ---------------------------------------------------------------------------\r\n\r\nexport async function* synthesizerWorker(\r\n  textQueue: AsyncIterable<string>,\r\n  voiceConfig: PiperVoiceConfig,\r\n  synth: Synthesizer,\r\n): AsyncGenerator<SynthResult, void, unknown> {\r\n  const voice = await ensureVoiceLoaded(voiceConfig);\r\n  for await (const text of textQueue) {\r\n    yield synth(text, voice);\r\n  }\r\n}\r\n\r\nexport async function playerWorker(\r\n  audioQueue: AsyncIterable<SynthResult>,\r\n  play: Player,\r\n): Promise<void> {\r\n  for await (const audio of audioQueue) {\r\n    await play(audio);\r\n  }\r\n}\r\n\r\nexport function nextBoundaryIndex(text: string): number {\r\n  const idx = text.search(/[.!?,]/);\r\n  return idx >= 0 ? idx : -1;\r\n}\r\n\r\nexport function emitSentence(queue: SimpleQueue<string>, sentence: string): void {\r\n  const trimmed = sentence.trim();\r\n  if (trimmed) {\r\n    queue.put(trimmed);\r\n  }\r\n}\r\n\r\nexport function handleChunk(state: { buffer: string }, chunk: string, queue: SimpleQueue<string>): void {\r\n  state.buffer += chunk;\r\n  let boundary = nextBoundaryIndex(state.buffer);\r\n  while (boundary >= 0) {\r\n    const sentence = state.buffer.slice(0, boundary + 1);\r\n    state.buffer = state.buffer.slice(boundary + 1);\r\n    emitSentence(queue, sentence);\r\n    boundary = nextBoundaryIndex(state.buffer);\r\n  }\r\n}\r\n\r\nexport function getAsyncIterator<T>(\r\n  source: AsyncIterable<T> | Iterable<T>,\r\n): AsyncIterable<T> {\r\n  if ((source as AsyncIterable<T>)[Symbol.asyncIterator]) {\r\n    return source as AsyncIterable<T>;\r\n  }\r\n  return {\r\n    async *[Symbol.asyncIterator]() {\r\n      for (const item of source as Iterable<T>) {\r\n        yield item;\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\nexport class SimpleQueue<T> implements AsyncIterable<T> {\r\n  private buffer: T[] = [];\r\n  private resolvers: Array<(value: IteratorResult<T>) => void> = [];\r\n\r\n  put(item: T): void {\r\n    if (this.resolvers.length > 0) {\r\n      const resolve = this.resolvers.shift();\r\n      resolve?.({ value: item, done: false });\r\n    } else {\r\n      this.buffer.push(item);\r\n    }\r\n  }\r\n\r\n  size(): number {\r\n    return this.buffer.length;\r\n  }\r\n\r\n  async get(): Promise<T> {\r\n    if (this.buffer.length > 0) {\r\n      return this.buffer.shift() as T;\r\n    }\r\n    return new Promise<T>((resolve) => {\r\n      this.resolvers.push(({ value }) => resolve(value as T));\r\n    });\r\n  }\r\n\r\n  async *[Symbol.asyncIterator](): AsyncIterator<T> {\r\n    while (true) {\r\n      const value = await this.get();\r\n      yield value;\r\n    }\r\n  }\r\n}\r\n","/**\r\n * stt-tts-lib - Speech-to-Text and Text-to-Speech Library\r\n * Copyright (C) 2026 Navgurukul\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\nimport { streamTokensToSpeech } from \"./stream-tokens-to-speech.js\";\r\nimport {\r\n  ensureOrtReady,\r\n  ensureVoiceLoaded,\r\n  handleChunk,\r\n  SimpleQueue,\r\n  synthesizerWorker,\r\n  playerWorker,\r\n  getAsyncIterator,\r\n  emitSentence,\r\n} from \"./piper.js\";\r\nimport type { PiperVoiceConfig, PreparedPiperVoice } from \"./prepare-piper-voice.js\";\r\nimport type { OrtEnvironmentConfig } from \"./ort-setup.js\";\r\nimport type { SynthResult, Synthesizer, Player } from \"./piper.js\";\r\n\r\nexport interface StreamingTTSOptions {\r\n  voice: PiperVoiceConfig;\r\n  ort?: OrtEnvironmentConfig;\r\n  synth?: Synthesizer;\r\n  play?: Player;\r\n  chunkSize?: number;\r\n  delayMs?: number;\r\n}\r\n\r\nexport interface StreamingTTSController {\r\n  ensureReady(): Promise<void>;\r\n  addChunk(text: string): Promise<void>;\r\n  finishStreaming(): Promise<void>;\r\n  stop(): void;\r\n  synthAndPlayChunk(text: string): Promise<void>;\r\n  processQueue(): Promise<void>;\r\n  createTokenIterable(text: string): Iterable<string>;\r\n}\r\n\r\nconst defaultSynth: Synthesizer = async (text) => text;\r\nconst defaultPlayer: Player = async () => undefined;\r\n\r\nexport function useStreamingTTS(options: StreamingTTSOptions): StreamingTTSController {\r\n  const textQueue = new SimpleQueue<string>();\r\n  const audioQueue = new SimpleQueue<SynthResult>();\r\n  const bufferState = { buffer: \"\" };\r\n\r\n  let ready = false;\r\n  let stopped = false;\r\n  let voice: PreparedPiperVoice | null = null;\r\n\r\n  const synth = options.synth ?? defaultSynth;\r\n  const play = options.play ?? defaultPlayer;\r\n  const chunkSize = options.chunkSize ?? 48;\r\n  const delayMs = options.delayMs ?? 0;\r\n\r\n  async function ensureReady(): Promise<void> {\r\n    if (ready) return;\r\n    await ensureOrtReady(options.ort ?? {});\r\n    voice = await ensureVoiceLoaded(options.voice);\r\n    ready = true;\r\n  }\r\n\r\n  async function addChunk(text: string): Promise<void> {\r\n    handleChunk(bufferState, text, textQueue);\r\n    if (bufferState.buffer.length >= chunkSize) {\r\n      emitSentence(textQueue, bufferState.buffer);\r\n      bufferState.buffer = \"\";\r\n    }\r\n  }\r\n\r\n  async function finishStreaming(): Promise<void> {\r\n    if (bufferState.buffer) {\r\n      emitSentence(textQueue, bufferState.buffer);\r\n      bufferState.buffer = \"\";\r\n    }\r\n  }\r\n\r\n  function stop(): void {\r\n    stopped = true;\r\n  }\r\n\r\n  async function synthAndPlayChunk(text: string): Promise<void> {\r\n    await ensureReady();\r\n    const audio = await synth(text, voice as PreparedPiperVoice);\r\n    await play(audio);\r\n  }\r\n\r\n  async function processQueue(): Promise<void> {\r\n    await ensureReady();\r\n    const tokenIterator = getAsyncIterator(textQueue as AsyncIterable<string>);\r\n    const audioIterator = synthesizerWorker(tokenIterator, options.voice, synth);\r\n    await playerWorker(audioIterator, play);\r\n  }\r\n\r\n  function createTokenIterable(text: string): Iterable<string> {\r\n    return text.split(/\\s+/g).filter(Boolean);\r\n  }\r\n\r\n  async function streamTokens(tokens: AsyncIterable<string> | Iterable<string>): Promise<void> {\r\n    await ensureReady();\r\n    await streamTokensToSpeech(tokens, {\r\n      chunkSize,\r\n      delayMs,\r\n      onChunk: async (chunk) => {\r\n        if (stopped) return;\r\n        await synthAndPlayChunk(chunk);\r\n      },\r\n    });\r\n  }\r\n\r\n  // Kick off background processors\r\n  processQueue().catch(() => undefined);\r\n  streamTokens(textQueue as AsyncIterable<string>).catch(() => undefined);\r\n\r\n  return {\r\n    ensureReady,\r\n    addChunk,\r\n    finishStreaming,\r\n    stop,\r\n    synthAndPlayChunk,\r\n    processQueue,\r\n    createTokenIterable,\r\n  };\r\n}\r\n"]}