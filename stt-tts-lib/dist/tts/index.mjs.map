{"version":3,"sources":["../../src/tts/prepare-piper-voice.ts","../../src/tts/stream-tokens-to-speech.ts","../../src/tts/ort-setup.ts","../../src/tts/piper.ts","../../src/tts/use-streaming-tts.ts","../../src/internal/speech-state.ts","../../src/tts/audio-player.ts","../../src/tts/piper-synthesizer.ts","../../src/tts/filler-manager.ts"],"names":[],"mappings":"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","file":"index.mjs","sourcesContent":["/**\r\n * stt-tts-lib - Speech-to-Text and Text-to-Speech Library\r\n * Copyright (C) 2026 Navgurukul\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\nexport interface PiperVoiceConfig {\r\n  voiceId: string;\r\n  modelPath?: string;\r\n  sampleRate?: number;\r\n  lengthScale?: number;\r\n  noiseScale?: number;\r\n  speaker?: string;\r\n}\r\n\r\nexport interface PreparedPiperVoice {\r\n  voiceId: string;\r\n  modelPath: string;\r\n  sampleRate: number;\r\n  inference: {\r\n    lengthScale: number;\r\n    noiseScale: number;\r\n  };\r\n  metadata: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Normalize Piper voice configuration so downstream synthesis gets predictable defaults.\r\n */\r\nexport function preparePiperVoice(config: PiperVoiceConfig): PreparedPiperVoice {\r\n  const modelPath = config.modelPath ?? `voices/${config.voiceId}.onnx`;\r\n\r\n  return {\r\n    voiceId: config.voiceId,\r\n    modelPath,\r\n    sampleRate: config.sampleRate ?? 22050,\r\n    inference: {\r\n      lengthScale: config.lengthScale ?? 1.0,\r\n      noiseScale: config.noiseScale ?? 0.667,\r\n    },\r\n    metadata: {\r\n      speaker: config.speaker ?? \"default\",\r\n    },\r\n  };\r\n}\r\n","/**\r\n * stt-tts-lib - Speech-to-Text and Text-to-Speech Library\r\n * Copyright (C) 2026 Navgurukul\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\nexport interface StreamTokensOptions {\r\n  chunkSize?: number;\r\n  delayMs?: number;\r\n  onChunk?: (text: string) => Promise<void> | void;\r\n}\r\n\r\nexport interface StreamTokensResult {\r\n  chunksEmitted: number;\r\n  characters: number;\r\n}\r\n\r\nfunction isAsyncIterable<T>(value: AsyncIterable<T> | Iterable<T>): value is AsyncIterable<T> {\r\n  return typeof (value as AsyncIterable<T>)[Symbol.asyncIterator] === \"function\";\r\n}\r\n\r\nconst sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\r\n\r\n/**\r\n * Convert incremental tokens to speech-sized chunks. Consumers can bridge this into an audio renderer.\r\n */\r\nexport async function streamTokensToSpeech(\r\n  tokens: AsyncIterable<string> | Iterable<string>,\r\n  options: StreamTokensOptions = {},\r\n): Promise<StreamTokensResult> {\r\n  const chunkSize = options.chunkSize ?? 40;\r\n  const delayMs = options.delayMs ?? 0;\r\n\r\n  let buffer = \"\";\r\n  let chunksEmitted = 0;\r\n  let characters = 0;\r\n\r\n  const emit = async () => {\r\n    if (!buffer) return;\r\n    characters += buffer.length;\r\n    chunksEmitted += 1;\r\n    if (options.onChunk) {\r\n      await options.onChunk(buffer);\r\n    }\r\n    buffer = \"\";\r\n    if (delayMs > 0) {\r\n      await sleep(delayMs);\r\n    }\r\n  };\r\n\r\n  if (isAsyncIterable(tokens)) {\r\n    for await (const token of tokens) {\r\n      buffer += token;\r\n      if (buffer.length >= chunkSize) {\r\n        await emit();\r\n      }\r\n    }\r\n  } else {\r\n    for (const token of tokens) {\r\n      buffer += token;\r\n      if (buffer.length >= chunkSize) {\r\n        await emit();\r\n      }\r\n    }\r\n  }\r\n\r\n  if (buffer) {\r\n    await emit();\r\n  }\r\n\r\n  return { chunksEmitted, characters };\r\n}\r\n","/**\r\n * stt-tts-lib - Speech-to-Text and Text-to-Speech Library\r\n * Copyright (C) 2026 Navgurukul\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\nexport type OrtDevice = \"cpu\" | \"webgpu\";\r\nexport type OrtLogLevel = \"verbose\" | \"warning\" | \"error\";\r\n\r\nexport interface OrtEnvironmentConfig {\r\n  device?: OrtDevice;\r\n  logLevel?: OrtLogLevel;\r\n  providers?: string[];\r\n}\r\n\r\nexport interface OrtEnvironment {\r\n  device: OrtDevice;\r\n  logLevel: OrtLogLevel;\r\n  providers: string[];\r\n  initialized: boolean;\r\n  init: () => Promise<void>;\r\n}\r\n\r\n/**\r\n * Minimal Onnx Runtime bootstrapper. This is intentionally dependency-light: callers can pass\r\n * a custom provider list when integrating with onnxruntime-web or node-ort.\r\n */\r\nexport async function createOrtEnvironment(\r\n  config: OrtEnvironmentConfig = {},\r\n): Promise<OrtEnvironment> {\r\n  const providers = config.providers ?? (config.device === \"webgpu\" ? [\"webgpu\", \"wasm\"] : [\"wasm\"]);\r\n\r\n  const environment: OrtEnvironment = {\r\n    device: config.device ?? \"cpu\",\r\n    logLevel: config.logLevel ?? \"warning\",\r\n    providers,\r\n    initialized: false,\r\n    async init() {\r\n      // Real implementation would call into the ORT API. Here we just flip a flag for consumers.\r\n      this.initialized = true;\r\n    },\r\n  };\r\n\r\n  await environment.init();\r\n  return environment;\r\n}\r\n","/**\r\n * stt-tts-lib - Speech-to-Text and Text-to-Speech Library\r\n * Copyright (C) 2026 Navgurukul\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\nimport { createOrtEnvironment, OrtEnvironment, OrtEnvironmentConfig } from \"./ort-setup.js\";\r\nimport { preparePiperVoice, PiperVoiceConfig, PreparedPiperVoice } from \"./prepare-piper-voice.js\";\r\n\r\nexport type SynthResult = string | ArrayBuffer | Uint8Array;\r\nexport type Synthesizer = (text: string, voice: PreparedPiperVoice) => Promise<SynthResult>;\r\nexport type Player = (audio: SynthResult) => Promise<void>;\r\n\r\nconst voiceCache = new Map<string, PreparedPiperVoice>();\r\nlet ortEnv: OrtEnvironment | null = null;\r\n\r\nexport async function ensureOrtReady(config: OrtEnvironmentConfig = {}): Promise<OrtEnvironment> {\r\n  if (ortEnv) return ortEnv;\r\n  ortEnv = await createOrtEnvironment(config);\r\n  return ortEnv;\r\n}\r\n\r\nexport async function ensureVoiceLoaded(config: PiperVoiceConfig): Promise<PreparedPiperVoice> {\r\n  const cached = voiceCache.get(config.voiceId);\r\n  if (cached) return cached;\r\n  const voice = preparePiperVoice(config);\r\n  voiceCache.set(config.voiceId, voice);\r\n  return voice;\r\n}\r\n\r\nexport async function warmupPiper(\r\n  voiceConfig: PiperVoiceConfig,\r\n  synth: Synthesizer,\r\n  text = \"warmup\",\r\n): Promise<void> {\r\n  const voice = await ensureVoiceLoaded(voiceConfig);\r\n  await synth(text, voice);\r\n}\r\n\r\nexport function resetVoiceCache(): void {\r\n  voiceCache.clear();\r\n}\r\n\r\nexport function getBackendLabel(device: string | undefined): string {\r\n  if (!device) return \"auto\";\r\n  return device === \"webgpu\" ? \"WebGPU\" : \"CPU\";\r\n}\r\n\r\nexport function isCorruptModelError(error: unknown): boolean {\r\n  if (!error) return false;\r\n  const msg = typeof error === \"string\" ? error : (error as { message?: string }).message;\r\n  if (!msg) return false;\r\n  return /corrupt|checksum|integrity/i.test(msg);\r\n}\r\n\r\n// ---------------------------------------------------------------------------\r\n// Workers and helpers\r\n// ---------------------------------------------------------------------------\r\n\r\nexport async function* synthesizerWorker(\r\n  textQueue: AsyncIterable<string>,\r\n  voiceConfig: PiperVoiceConfig,\r\n  synth: Synthesizer,\r\n): AsyncGenerator<SynthResult, void, unknown> {\r\n  const voice = await ensureVoiceLoaded(voiceConfig);\r\n  for await (const text of textQueue) {\r\n    yield synth(text, voice);\r\n  }\r\n}\r\n\r\nexport async function playerWorker(\r\n  audioQueue: AsyncIterable<SynthResult>,\r\n  play: Player,\r\n): Promise<void> {\r\n  for await (const audio of audioQueue) {\r\n    await play(audio);\r\n  }\r\n}\r\n\r\nexport function nextBoundaryIndex(text: string): number {\r\n  const idx = text.search(/[.!?,]/);\r\n  return idx >= 0 ? idx : -1;\r\n}\r\n\r\nexport function emitSentence(queue: SimpleQueue<string>, sentence: string): void {\r\n  const trimmed = sentence.trim();\r\n  if (trimmed) {\r\n    queue.put(trimmed);\r\n  }\r\n}\r\n\r\nexport function handleChunk(state: { buffer: string }, chunk: string, queue: SimpleQueue<string>): void {\r\n  state.buffer += chunk;\r\n  let boundary = nextBoundaryIndex(state.buffer);\r\n  while (boundary >= 0) {\r\n    const sentence = state.buffer.slice(0, boundary + 1);\r\n    state.buffer = state.buffer.slice(boundary + 1);\r\n    emitSentence(queue, sentence);\r\n    boundary = nextBoundaryIndex(state.buffer);\r\n  }\r\n}\r\n\r\nexport function getAsyncIterator<T>(\r\n  source: AsyncIterable<T> | Iterable<T>,\r\n): AsyncIterable<T> {\r\n  if ((source as AsyncIterable<T>)[Symbol.asyncIterator]) {\r\n    return source as AsyncIterable<T>;\r\n  }\r\n  return {\r\n    async *[Symbol.asyncIterator]() {\r\n      for (const item of source as Iterable<T>) {\r\n        yield item;\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\nexport class SimpleQueue<T> implements AsyncIterable<T> {\r\n  private buffer: T[] = [];\r\n  private resolvers: Array<(value: IteratorResult<T>) => void> = [];\r\n\r\n  put(item: T): void {\r\n    if (this.resolvers.length > 0) {\r\n      const resolve = this.resolvers.shift();\r\n      resolve?.({ value: item, done: false });\r\n    } else {\r\n      this.buffer.push(item);\r\n    }\r\n  }\r\n\r\n  size(): number {\r\n    return this.buffer.length;\r\n  }\r\n\r\n  async get(): Promise<T> {\r\n    if (this.buffer.length > 0) {\r\n      return this.buffer.shift() as T;\r\n    }\r\n    return new Promise<T>((resolve) => {\r\n      this.resolvers.push(({ value }) => resolve(value as T));\r\n    });\r\n  }\r\n\r\n  async *[Symbol.asyncIterator](): AsyncIterator<T> {\r\n    while (true) {\r\n      const value = await this.get();\r\n      yield value;\r\n    }\r\n  }\r\n}\r\n","/**\r\n * stt-tts-lib - Speech-to-Text and Text-to-Speech Library\r\n * Copyright (C) 2026 Navgurukul\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\nimport { streamTokensToSpeech } from \"./stream-tokens-to-speech.js\";\r\nimport {\r\n  ensureOrtReady,\r\n  ensureVoiceLoaded,\r\n  handleChunk,\r\n  SimpleQueue,\r\n  synthesizerWorker,\r\n  playerWorker,\r\n  getAsyncIterator,\r\n  emitSentence,\r\n} from \"./piper.js\";\r\nimport type { PiperVoiceConfig, PreparedPiperVoice } from \"./prepare-piper-voice.js\";\r\nimport type { OrtEnvironmentConfig } from \"./ort-setup.js\";\r\nimport type { SynthResult, Synthesizer, Player } from \"./piper.js\";\r\n\r\nexport interface StreamingTTSOptions {\r\n  voice: PiperVoiceConfig;\r\n  ort?: OrtEnvironmentConfig;\r\n  synth?: Synthesizer;\r\n  play?: Player;\r\n  chunkSize?: number;\r\n  delayMs?: number;\r\n}\r\n\r\nexport interface StreamingTTSController {\r\n  ensureReady(): Promise<void>;\r\n  addChunk(text: string): Promise<void>;\r\n  finishStreaming(): Promise<void>;\r\n  stop(): void;\r\n  synthAndPlayChunk(text: string): Promise<void>;\r\n  processQueue(): Promise<void>;\r\n  createTokenIterable(text: string): Iterable<string>;\r\n}\r\n\r\nconst defaultSynth: Synthesizer = async (text) => text;\r\nconst defaultPlayer: Player = async () => undefined;\r\n\r\nexport function useStreamingTTS(options: StreamingTTSOptions): StreamingTTSController {\r\n  const textQueue = new SimpleQueue<string>();\r\n  const audioQueue = new SimpleQueue<SynthResult>();\r\n  const bufferState = { buffer: \"\" };\r\n\r\n  let ready = false;\r\n  let stopped = false;\r\n  let voice: PreparedPiperVoice | null = null;\r\n\r\n  const synth = options.synth ?? defaultSynth;\r\n  const play = options.play ?? defaultPlayer;\r\n  const chunkSize = options.chunkSize ?? 48;\r\n  const delayMs = options.delayMs ?? 0;\r\n\r\n  async function ensureReady(): Promise<void> {\r\n    if (ready) return;\r\n    await ensureOrtReady(options.ort ?? {});\r\n    voice = await ensureVoiceLoaded(options.voice);\r\n    ready = true;\r\n  }\r\n\r\n  async function addChunk(text: string): Promise<void> {\r\n    handleChunk(bufferState, text, textQueue);\r\n    if (bufferState.buffer.length >= chunkSize) {\r\n      emitSentence(textQueue, bufferState.buffer);\r\n      bufferState.buffer = \"\";\r\n    }\r\n  }\r\n\r\n  async function finishStreaming(): Promise<void> {\r\n    if (bufferState.buffer) {\r\n      emitSentence(textQueue, bufferState.buffer);\r\n      bufferState.buffer = \"\";\r\n    }\r\n  }\r\n\r\n  function stop(): void {\r\n    stopped = true;\r\n  }\r\n\r\n  async function synthAndPlayChunk(text: string): Promise<void> {\r\n    await ensureReady();\r\n    const audio = await synth(text, voice as PreparedPiperVoice);\r\n    await play(audio);\r\n  }\r\n\r\n  async function processQueue(): Promise<void> {\r\n    await ensureReady();\r\n    const tokenIterator = getAsyncIterator(textQueue as AsyncIterable<string>);\r\n    const audioIterator = synthesizerWorker(tokenIterator, options.voice, synth);\r\n    await playerWorker(audioIterator, play);\r\n  }\r\n\r\n  function createTokenIterable(text: string): Iterable<string> {\r\n    return text.split(/\\s+/g).filter(Boolean);\r\n  }\r\n\r\n  async function streamTokens(tokens: AsyncIterable<string> | Iterable<string>): Promise<void> {\r\n    await ensureReady();\r\n    await streamTokensToSpeech(tokens, {\r\n      chunkSize,\r\n      delayMs,\r\n      onChunk: async (chunk) => {\r\n        if (stopped) return;\r\n        await synthAndPlayChunk(chunk);\r\n      },\r\n    });\r\n  }\r\n\r\n  // Kick off background processors\r\n  processQueue().catch(() => undefined);\r\n  streamTokens(textQueue as AsyncIterable<string>).catch(() => undefined);\r\n\r\n  return {\r\n    ensureReady,\r\n    addChunk,\r\n    finishStreaming,\r\n    stop,\r\n    synthAndPlayChunk,\r\n    processQueue,\r\n    createTokenIterable,\r\n  };\r\n}\r\n","/**\r\n * Internal Speech State Manager\r\n *\r\n * Shared state between STTLogic and AudioPlayer.\r\n * NOT exported to consumers - internal library use only.\r\n */\r\n\r\ntype SpeechStateListener = (speaking: boolean) => void;\r\n\r\nclass SpeechStateManager {\r\n  private speaking = false;\r\n  private listeners: SpeechStateListener[] = [];\r\n\r\n  /**\r\n   * Set speaking state (called by STTLogic)\r\n   */\r\n  setSpeaking(speaking: boolean): void {\r\n    if (this.speaking === speaking) return;\r\n    this.speaking = speaking;\r\n    this.listeners.forEach((listener) => listener(speaking));\r\n  }\r\n\r\n  /**\r\n   * Get current speaking state\r\n   */\r\n  isSpeaking(): boolean {\r\n    return this.speaking;\r\n  }\r\n\r\n  /**\r\n   * Subscribe to speaking state changes (called by AudioPlayer)\r\n   */\r\n  onSpeakingChange(listener: SpeechStateListener): () => void {\r\n    this.listeners.push(listener);\r\n    // Return unsubscribe function\r\n    return () => {\r\n      this.listeners = this.listeners.filter((l) => l !== listener);\r\n    };\r\n  }\r\n}\r\n\r\n// Internal singleton - not exported to consumers\r\nexport const internalSpeechState = new SpeechStateManager();\r\n","/**\r\n * stt-tts-lib - Speech-to-Text and Text-to-Speech Library\r\n * Copyright (C) 2026 Navgurukul\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\nimport { internalSpeechState } from \"../internal/speech-state\";\r\n\r\n/**\r\n * Web Audio API Player with Singleton Support\r\n *\r\n * Can be used as:\r\n * 1. Singleton (recommended): sharedAudioPlayer - same queue across entire app\r\n * 2. Custom instance: new AudioPlayer(config) - separate queue\r\n *\r\n * Speech-aware: Automatically pauses queue when user is speaking (via STTLogic).\r\n */\r\n\r\nexport interface AudioPlayerConfig {\r\n  sampleRate?: number;\r\n  volume?: number;\r\n  autoPlay?: boolean;\r\n}\r\n\r\nexport interface QueuedAudio {\r\n  audioData: Float32Array;\r\n  sampleRate: number;\r\n}\r\n\r\nexport type AudioPlayerStatusCallback = (status: string) => void;\r\nexport type PlayingStateCallback = (playing: boolean) => void;\r\n\r\n/**\r\n * Audio Player for Web Audio API\r\n * Supports queue-based playback with autoPlay\r\n */\r\nexport class AudioPlayer {\r\n  private static instance: AudioPlayer | null = null;\r\n  private static sharedConfig: AudioPlayerConfig = {\r\n    sampleRate: 22050,\r\n    volume: 1.0,\r\n    autoPlay: true,\r\n  };\r\n\r\n  private audioContext: AudioContext | null = null;\r\n  private config: AudioPlayerConfig;\r\n  private currentSource: AudioBufferSourceNode | null = null;\r\n\r\n  // Queue-related properties\r\n  private audioQueue: QueuedAudio[] = [];\r\n  private isPlaying = false;\r\n  private isQueueProcessing = false;\r\n  private onStatusCallback?: AudioPlayerStatusCallback;\r\n  private onPlayingChangeCallback?: PlayingStateCallback;\r\n\r\n  // Speech-aware playback: pause queue while user is speaking\r\n  private userSpeaking = false;\r\n  private onUserSpeakingChangeCallback?: (speaking: boolean) => void;\r\n  private speechStateUnsubscribe?: () => void;\r\n\r\n  constructor(config: AudioPlayerConfig = {}) {\r\n    this.config = {\r\n      sampleRate: 22050,\r\n      volume: 1.0,\r\n      autoPlay: false,\r\n      ...config,\r\n    };\r\n\r\n    // Auto-subscribe to internal speech state (from STTLogic)\r\n    this.speechStateUnsubscribe = internalSpeechState.onSpeakingChange(\r\n      (speaking) => {\r\n        this.setUserSpeaking(speaking);\r\n      }\r\n    );\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Singleton Methods (Static)\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Configure the shared singleton (call before first use)\r\n   */\r\n  static configure(config: AudioPlayerConfig): void {\r\n    if (AudioPlayer.instance) {\r\n      console.log(\r\n        \"[AudioPlayer] Singleton already initialized. Call reset() first to reconfigure.\"\r\n      );\r\n      return;\r\n    }\r\n    AudioPlayer.sharedConfig = { ...AudioPlayer.sharedConfig, ...config };\r\n  }\r\n\r\n  /**\r\n   * Get the singleton instance (creates if not exists)\r\n   */\r\n  static getInstance(): AudioPlayer {\r\n    if (!AudioPlayer.instance) {\r\n      AudioPlayer.instance = new AudioPlayer(AudioPlayer.sharedConfig);\r\n      console.log(\r\n        \"[AudioPlayer] Singleton initialized with config:\",\r\n        AudioPlayer.sharedConfig\r\n      );\r\n    }\r\n    return AudioPlayer.instance;\r\n  }\r\n\r\n  /**\r\n   * Reset the singleton (for reconfiguration)\r\n   */\r\n  static async reset(): Promise<void> {\r\n    if (AudioPlayer.instance) {\r\n      await AudioPlayer.instance.close();\r\n      AudioPlayer.instance = null;\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Instance Methods\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Set status callback for logging\r\n   */\r\n  setStatusCallback(callback: AudioPlayerStatusCallback): void {\r\n    this.onStatusCallback = callback;\r\n  }\r\n\r\n  /**\r\n   * Set callback for playing state changes\r\n   */\r\n  setPlayingChangeCallback(callback: PlayingStateCallback): void {\r\n    this.onPlayingChangeCallback = callback;\r\n  }\r\n\r\n  /**\r\n   * Check if audio is currently playing\r\n   */\r\n  isAudioPlaying(): boolean {\r\n    return this.isPlaying;\r\n  }\r\n\r\n  /**\r\n   * Get current queue size\r\n   */\r\n  getQueueSize(): number {\r\n    return this.audioQueue.length;\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Speech-Aware Playback\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Set user speaking state\r\n   * When user is speaking, queue playback is paused\r\n   * When user stops speaking, queue playback resumes (if autoPlay enabled)\r\n   */\r\n  setUserSpeaking(speaking: boolean): void {\r\n    if (this.userSpeaking === speaking) return;\r\n\r\n    this.userSpeaking = speaking;\r\n    this.log(`[AudioPlayer] User speaking: ${speaking}`);\r\n    this.onUserSpeakingChangeCallback?.(speaking);\r\n\r\n    // When user stops speaking, resume queue playback if autoPlay is enabled\r\n    if (!speaking && this.config.autoPlay && this.audioQueue.length > 0) {\r\n      this.log(\"[AudioPlayer] User stopped speaking, resuming queue playback\");\r\n      this.playAudiosFromQueue();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if user is currently speaking\r\n   */\r\n  isUserSpeaking(): boolean {\r\n    return this.userSpeaking;\r\n  }\r\n\r\n  /**\r\n   * Set callback for user speaking state changes\r\n   */\r\n  setUserSpeakingChangeCallback(callback: (speaking: boolean) => void): void {\r\n    this.onUserSpeakingChangeCallback = callback;\r\n  }\r\n\r\n  /**\r\n   * Add audio to the queue\r\n   * Note: If user is speaking, audio is queued but NOT played until user stops\r\n   */\r\n  addAudioIntoQueue(audioData: Float32Array, sampleRate?: number): void {\r\n    const audio: QueuedAudio = {\r\n      audioData,\r\n      sampleRate: sampleRate ?? this.config.sampleRate!,\r\n    };\r\n    this.audioQueue.push(audio);\r\n    this.log(\r\n      `[AudioPlayer] Added audio to queue (samples: ${audioData.length}, queue size: ${this.audioQueue.length}, userSpeaking: ${this.userSpeaking})`\r\n    );\r\n\r\n    // Don't start playback if already processing\r\n    if (this.isQueueProcessing) {\r\n      return;\r\n    }\r\n\r\n    // Don't start playback if user is speaking - wait until they stop\r\n    if (this.userSpeaking) {\r\n      this.log(\r\n        \"[AudioPlayer] User is speaking, audio queued but playback paused\"\r\n      );\r\n      return;\r\n    }\r\n\r\n    // Start playback if autoPlay enabled\r\n    if (this.config.autoPlay) {\r\n      this.playAudiosFromQueue();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start playing audios from the queue sequentially\r\n   * Pauses if user starts speaking, resumes when they stop\r\n   */\r\n  async playAudiosFromQueue(): Promise<void> {\r\n    if (this.audioQueue.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Don't start if user is speaking\r\n    if (this.userSpeaking) {\r\n      this.log(\"[AudioPlayer] Cannot start queue playback - user is speaking\");\r\n      return;\r\n    }\r\n\r\n    this.isQueueProcessing = true;\r\n    this.log(\"[AudioPlayer] Starting queue playback\");\r\n\r\n    try {\r\n      while (this.audioQueue.length > 0) {\r\n        // Pause playback if user starts speaking mid-queue\r\n        if (this.userSpeaking) {\r\n          this.log(\r\n            \"[AudioPlayer] User started speaking, pausing queue playback\"\r\n          );\r\n          break;\r\n        }\r\n\r\n        const audio = this.audioQueue.shift();\r\n        if (audio) {\r\n          this.setPlayingState(true);\r\n          await this.play(audio.audioData, audio.sampleRate);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.log(`[AudioPlayer] Queue playback error: ${error}`);\r\n    } finally {\r\n      this.isQueueProcessing = false;\r\n      this.setPlayingState(false);\r\n      this.log(\"[AudioPlayer] Queue playback finished\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Play audio data directly\r\n   */\r\n  async play(audioData: Float32Array, sampleRate: number): Promise<void> {\r\n    const ctx = this.getAudioContext();\r\n\r\n    if (ctx.state === \"suspended\") {\r\n      await ctx.resume();\r\n    }\r\n\r\n    const audioBuffer = ctx.createBuffer(1, audioData.length, sampleRate);\r\n    audioBuffer.getChannelData(0).set(audioData);\r\n\r\n    const source = ctx.createBufferSource();\r\n    source.buffer = audioBuffer;\r\n\r\n    const gainNode = ctx.createGain();\r\n    gainNode.gain.value = this.config.volume!;\r\n\r\n    source.connect(gainNode);\r\n    gainNode.connect(ctx.destination);\r\n\r\n    this.currentSource = source;\r\n    source.start(0);\r\n\r\n    return new Promise<void>((resolve) => {\r\n      source.onended = () => {\r\n        this.currentSource = null;\r\n        resolve();\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Stop current playback (does not clear queue)\r\n   */\r\n  stop(): void {\r\n    if (this.currentSource) {\r\n      try {\r\n        this.currentSource.stop();\r\n        this.currentSource = null;\r\n      } catch (error) {\r\n        // Ignore errors if already stopped\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear the audio queue\r\n   */\r\n  clearQueue(): void {\r\n    this.audioQueue = [];\r\n    this.log(\"[AudioPlayer] Queue cleared\");\r\n  }\r\n\r\n  /**\r\n   * Stop playback and clear the queue\r\n   */\r\n  stopAndClearQueue(): void {\r\n    this.isQueueProcessing = false;\r\n    this.stop();\r\n    this.clearQueue();\r\n    this.setPlayingState(false);\r\n    this.log(\"[AudioPlayer] Stopped playback and cleared queue\");\r\n  }\r\n\r\n  /**\r\n   * Wait for all queued audio to finish playing\r\n   */\r\n  async waitForQueueCompletion(): Promise<void> {\r\n    while (this.audioQueue.length > 0 || this.isPlaying) {\r\n      await new Promise((resolve) => setTimeout(resolve, 50));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set volume (0.0 to 1.0)\r\n   */\r\n  setVolume(volume: number): void {\r\n    this.config.volume = Math.max(0, Math.min(1, volume));\r\n  }\r\n\r\n  /**\r\n   * Close the audio context and free resources\r\n   */\r\n  async close(): Promise<void> {\r\n    this.stop();\r\n    if (this.speechStateUnsubscribe) {\r\n      this.speechStateUnsubscribe();\r\n    }\r\n    if (this.audioContext) {\r\n      await this.audioContext.close();\r\n      this.audioContext = null;\r\n    }\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Private Methods\r\n  // ==========================================================================\r\n\r\n  private setPlayingState(playing: boolean): void {\r\n    if (this.isPlaying !== playing) {\r\n      this.isPlaying = playing;\r\n      this.onPlayingChangeCallback?.(playing);\r\n    }\r\n  }\r\n\r\n  private log(message: string): void {\r\n    console.log(message);\r\n    this.onStatusCallback?.(message);\r\n  }\r\n\r\n  private getAudioContext(): AudioContext {\r\n    if (!this.audioContext) {\r\n      this.audioContext = new (window.AudioContext ||\r\n        (window as any).webkitAudioContext)({\r\n        sampleRate: this.config.sampleRate,\r\n      });\r\n    }\r\n    return this.audioContext;\r\n  }\r\n}\r\n\r\n/**\r\n * Create a new AudioPlayer instance (separate queue)\r\n */\r\nexport function createAudioPlayer(config?: AudioPlayerConfig): AudioPlayer {\r\n  return new AudioPlayer(config);\r\n}\r\n\r\n/**\r\n * Shared AudioPlayer singleton\r\n * Same queue across STTLogic, TTSLogic, and consumer code\r\n *\r\n * Usage:\r\n *   // Configure once (optional)\r\n *   AudioPlayer.configure({ autoPlay: true });\r\n *\r\n *   // Use anywhere - same queue everywhere\r\n *   sharedAudioPlayer.addAudioIntoQueue(audioData, sampleRate);\r\n */\r\nexport const sharedAudioPlayer = {\r\n  /** Configure before first use */\r\n  configure: (config: AudioPlayerConfig) => AudioPlayer.configure(config),\r\n\r\n  /** Get the singleton instance */\r\n  getInstance: () => AudioPlayer.getInstance(),\r\n\r\n  /** Add audio to the shared queue */\r\n  addAudioIntoQueue: (audioData: Float32Array, sampleRate?: number) =>\r\n    AudioPlayer.getInstance().addAudioIntoQueue(audioData, sampleRate),\r\n\r\n  /** Play audio directly */\r\n  play: (audioData: Float32Array, sampleRate: number) =>\r\n    AudioPlayer.getInstance().play(audioData, sampleRate),\r\n\r\n  /** Start playing from queue */\r\n  playAudiosFromQueue: () => AudioPlayer.getInstance().playAudiosFromQueue(),\r\n\r\n  /** Check if playing */\r\n  isAudioPlaying: () => AudioPlayer.getInstance().isAudioPlaying(),\r\n\r\n  /** Get queue size */\r\n  getQueueSize: () => AudioPlayer.getInstance().getQueueSize(),\r\n\r\n  /** Stop playback */\r\n  stop: () => AudioPlayer.getInstance().stop(),\r\n\r\n  /** Clear queue */\r\n  clearQueue: () => AudioPlayer.getInstance().clearQueue(),\r\n\r\n  /** Stop and clear */\r\n  stopAndClearQueue: () => AudioPlayer.getInstance().stopAndClearQueue(),\r\n\r\n  /** Wait for completion */\r\n  waitForQueueCompletion: () =>\r\n    AudioPlayer.getInstance().waitForQueueCompletion(),\r\n\r\n  /** Set volume */\r\n  setVolume: (volume: number) => AudioPlayer.getInstance().setVolume(volume),\r\n\r\n  /** Set status callback */\r\n  setStatusCallback: (callback: AudioPlayerStatusCallback) =>\r\n    AudioPlayer.getInstance().setStatusCallback(callback),\r\n\r\n  /** Set playing state callback */\r\n  setPlayingChangeCallback: (callback: PlayingStateCallback) =>\r\n    AudioPlayer.getInstance().setPlayingChangeCallback(callback),\r\n\r\n  // Speech-aware playback (automatically managed by STTLogic)\r\n  /** Check if user is speaking */\r\n  isUserSpeaking: () => AudioPlayer.getInstance().isUserSpeaking(),\r\n\r\n  /** Set callback for speaking state changes */\r\n  setUserSpeakingChangeCallback: (callback: (speaking: boolean) => void) =>\r\n    AudioPlayer.getInstance().setUserSpeakingChangeCallback(callback),\r\n\r\n  /** Manual override for speaking state (usually not needed - handled by STTLogic) */\r\n  setUserSpeaking: (speaking: boolean) =>\r\n    AudioPlayer.getInstance().setUserSpeaking(speaking),\r\n\r\n  /** Reset singleton */\r\n  reset: () => AudioPlayer.reset(),\r\n\r\n  /** Close */\r\n  close: () => AudioPlayer.reset(),\r\n};\r\n","/**\r\n * stt-tts-lib - Speech-to-Text and Text-to-Speech Library\r\n * Copyright (C) 2026 Navgurukul\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Affero General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\n/**\r\n * Piper TTS Synthesizer using @realtimex/piper-tts-web\r\n * This library handles text-to-phoneme conversion properly using espeak-ng\r\n *\r\n * Note: @realtimex/piper-tts-web handles ONNX Runtime configuration internally,\r\n * so NO separate ort-setup.js is needed!\r\n */\r\n\r\nimport * as piperTts from \"@realtimex/piper-tts-web\";\r\nimport { AudioPlayer, sharedAudioPlayer } from \"./audio-player\";\r\n\r\nexport interface PiperSynthesizerConfig {\r\n  /** Voice ID (e.g., \"en_US-hfc_female-medium\") */\r\n  voiceId?: string;\r\n  /** Sample rate (default: 22050) */\r\n  sampleRate?: number;\r\n  /** Use shared audio player singleton (default: true) */\r\n  useSharedAudioPlayer?: boolean;\r\n  warmUp?: boolean;\r\n}\r\n\r\nexport interface SynthesisResult {\r\n  /** Audio data as WAV Blob */\r\n  audioBlob: Blob;\r\n  /** Audio data as Float32Array (for direct playback) */\r\n  audio: Float32Array;\r\n  /** Sample rate */\r\n  sampleRate: number;\r\n  /** Duration in seconds */\r\n  duration: number;\r\n}\r\n\r\nconst DEFAULT_VOICE_ID = \"en_US-hfc_female-medium\";\r\n\r\n/**\r\n * Piper TTS Synthesizer\r\n * Uses @mintplex-labs/piper-tts-web for proper text-to-speech conversion\r\n */\r\nexport class TTSLogic {\r\n  private config: PiperSynthesizerConfig;\r\n  private ready = false;\r\n  private voiceLoaded = false;\r\n  private audioPlayer?: AudioPlayer;\r\n  private useSharedPlayer: boolean;\r\n  private warmUp: boolean = true;\r\n\r\n  constructor(config: PiperSynthesizerConfig = {}) {\r\n    this.config = {\r\n      voiceId: DEFAULT_VOICE_ID,\r\n      sampleRate: 22050,\r\n      useSharedAudioPlayer: true,\r\n      warmUp: true,\r\n      ...config,\r\n    };\r\n    this.useSharedPlayer = this.config.useSharedAudioPlayer !== false;\r\n  }\r\n\r\n  /**\r\n   * Set a custom AudioPlayer (disables shared player for this instance)\r\n   */\r\n  setAudioPlayer(player: AudioPlayer): void {\r\n    this.audioPlayer = player;\r\n    this.useSharedPlayer = false;\r\n  }\r\n\r\n  /**\r\n   * Add audio to the queue (uses shared player by default, or custom if set)\r\n   */\r\n  addInternalAudioToQueue(audio: Float32Array, sampleRate?: number): void {\r\n    if (this.audioPlayer) {\r\n      // Use custom player if explicitly set\r\n      this.audioPlayer.addAudioIntoQueue(audio, sampleRate);\r\n    } else if (this.useSharedPlayer) {\r\n      // Use shared singleton player\r\n      sharedAudioPlayer.addAudioIntoQueue(audio, sampleRate);\r\n    }\r\n  }\r\n\r\n  async warmup(text = \"warmup\"): Promise<{ synthesized: boolean }> {\r\n    if (!this.voiceLoaded) {\r\n      throw new Error(\"Voice not loaded. Call initialize() first.\");\r\n    }\r\n    try {\r\n      // Call piperTts.predict directly to avoid ready check (warmup runs before ready=true)\r\n      await piperTts.predict({\r\n        text,\r\n        voiceId: this.config.voiceId!,\r\n      });\r\n      console.log(\" Piper synthesizer warmed up\");\r\n      return { synthesized: true };\r\n    } catch (error) {\r\n      throw new Error(`Failed to warm up Piper synthesizer: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize the synthesizer by loading the voice model\r\n   */\r\n  async initialize(): Promise<void> {\r\n    if (this.ready) return;\r\n\r\n    try {\r\n      const voiceId = this.config.voiceId!;\r\n      console.log(\" Loading Piper voice:\", voiceId);\r\n\r\n      // Check if voice is already cached\r\n      const storedVoices = await piperTts.stored();\r\n      const alreadyCached = Array.isArray(storedVoices)\r\n        ? storedVoices.includes(voiceId)\r\n        : false;\r\n\r\n      if (!alreadyCached) {\r\n        console.log(\" Downloading voice model...\");\r\n        await piperTts.download(voiceId, (progress) => {\r\n          if (progress?.total) {\r\n            const pct = Math.round((progress.loaded * 100) / progress.total);\r\n            console.log(` Downloading: ${pct}%`);\r\n          }\r\n        });\r\n      } else {\r\n        console.log(\" Voice found in cache\");\r\n      }\r\n      this.voiceLoaded = true;\r\n      if (this.config.warmUp) {\r\n        const { synthesized } = await this.warmup();\r\n        if (!synthesized) {\r\n          throw new Error(\r\n            \"Failed to warm up Piper synthesizer. Please check the voice model and try again.\"\r\n          );\r\n        }\r\n      }\r\n      this.ready = true;\r\n      console.log(\" Piper synthesizer initialized\");\r\n    } catch (error) {\r\n      throw new Error(`Failed to initialize Piper synthesizer: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if the synthesizer is ready\r\n   */\r\n  isReady(): boolean {\r\n    return this.ready;\r\n  }\r\n\r\n  /**\r\n   * Synthesize speech from text\r\n   * @param text - Text to convert to speech\r\n   * @returns Audio data as WAV Blob and Float32Array\r\n   */\r\n  async synthesize(text: string): Promise<SynthesisResult> {\r\n    if (!this.ready) {\r\n      throw new Error(\"Synthesizer not initialized. Call initialize() first.\");\r\n    }\r\n\r\n    const trimmed = text?.trim();\r\n    if (!trimmed) {\r\n      throw new Error(\"No text provided for synthesis\");\r\n    }\r\n\r\n    try {\r\n      // Use piper-tts-web to convert text to speech\r\n      // This handles text-to-phoneme conversion internally using espeak-ng\r\n      const wavBlob: Blob = await piperTts.predict({\r\n        text: trimmed,\r\n        voiceId: this.config.voiceId!,\r\n      });\r\n\r\n      // Convert Blob to Float32Array for direct playback\r\n      const arrayBuffer = await wavBlob.arrayBuffer();\r\n      const audioContext = new (window.AudioContext ||\r\n        (window as any).webkitAudioContext)();\r\n      const decodedBuffer = await audioContext.decodeAudioData(arrayBuffer);\r\n      const audioData = decodedBuffer.getChannelData(0);\r\n      audioContext.close();\r\n\r\n      return {\r\n        audioBlob: wavBlob,\r\n        audio: audioData,\r\n        sampleRate: decodedBuffer.sampleRate,\r\n        duration: decodedBuffer.duration,\r\n      };\r\n    } catch (error) {\r\n      throw new Error(`Synthesis failed: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Synthesize and return WAV Blob only (faster, no decoding)\r\n   */\r\n  async synthesizeToBlob(text: string): Promise<Blob> {\r\n    if (!this.ready) {\r\n      throw new Error(\"Synthesizer not initialized. Call initialize() first.\");\r\n    }\r\n\r\n    const trimmed = text?.trim();\r\n    if (!trimmed) {\r\n      throw new Error(\"No text provided for synthesis\");\r\n    }\r\n\r\n    return piperTts.predict({\r\n      text: trimmed,\r\n      voiceId: this.config.voiceId!,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Synthesize text and add to queue (uses shared player by default)\r\n   */\r\n  async synthesizeAndAddToQueue(text: string): Promise<void> {\r\n    if (!this.audioPlayer && !this.useSharedPlayer) {\r\n      throw new Error(\"No AudioPlayer set and shared player is disabled\");\r\n    }\r\n    const result = await this.synthesize(text);\r\n    this.addInternalAudioToQueue(result.audio, result.sampleRate);\r\n  }\r\n\r\n  /**\r\n   * Stop current synthesis (not directly supported, but we can track state)\r\n   */\r\n  stop(): void {\r\n    // Piper doesn't have a stop method, but we track state\r\n    console.log(\"Stop requested\");\r\n  }\r\n\r\n  /**\r\n   * Dispose of the synthesizer and free resources\r\n   */\r\n  async dispose(): Promise<void> {\r\n    this.ready = false;\r\n    this.voiceLoaded = false;\r\n  }\r\n}\r\n\r\n/**\r\n * Create and initialize a Piper synthesizer\r\n */\r\n// export async function createPiperSynthesizer(\r\n//   config: PiperSynthesizerConfig = {}\r\n// ): Promise<PiperSynthesizer> {\r\n//   const synthesizer = new PiperSynthesizer(config);\r\n//   await synthesizer.initialize();\r\n//   return synthesizer;\r\n// }\r\n\r\n/**\r\n * @deprecated Use PiperSynthesizer.synthesize() which handles text-to-phoneme internally\r\n * This is kept for backwards compatibility but should not be used directly\r\n */\r\nexport function textToPhonemes(_text: string): number[] {\r\n  console.warn(\r\n    \"textToPhonemes is deprecated. Use PiperSynthesizer.synthesize(text) instead.\"\r\n  );\r\n  return [];\r\n}\r\n","/**\r\n * stt-tts-lib - Filler Word Manager\r\n *\r\n * Generates contextual filler words using LLM at configurable intervals.\r\n * Audio is synthesized immediately but only plays when user stops speaking.\r\n */\r\n\r\nimport { sharedAudioPlayer } from \"./audio-player\";\r\nimport { internalSpeechState } from \"../internal/speech-state\";\r\nimport { TTSLogic } from \"./piper-synthesizer\";\r\n\r\n// System prompt for early (short) filler - brief acknowledgments\r\nconst SHORT_FILLER_SYSTEM_PROMPT = `\r\nYou are an *interviewer* listening to someone's answer.\r\nGenerate brief, natural filler words that show you're actively listening (5-12 words).\r\n\r\nExamples: \"Okay that makes sense\", \"Right I understand\", \"Got it\", \"I see where you're going\", \"Yeah that's a good point\"\r\n\r\nGuidelines:\r\n- Keep responses 5-12 words, natural and varied\r\n- Reference specific content from their speech if possible\r\n- Avoid punctuation except where natural\r\n- Stay in the same language as the user\r\n- If text is unclear, use generic acknowledgments like \"Okay I'm following\"\r\n\r\nOutput only your brief reaction. No explanations.\r\n`;\r\n\r\n// System prompt for late (long) filler - contextual rephrasing\r\nconst LONG_FILLER_SYSTEM_PROMPT = `\r\nYou are an *interviewer* listening to someone's answer.\r\nYour role is to rephrase what they said to show deep understanding (15-25 words).\r\n\r\nGuidelines:\r\n- Rephrase the user's partial message with specific context\r\n- Extract key concepts and mirror them back\r\n- Examples: \"So you're explaining how [concept] works...\", \"In other words the [topic] connects to...\"\r\n- Keep responses 15-25 words, declarative (not questions)\r\n- Reference their actual words and ideas\r\n- Stay in the same language as the user\r\n\r\nOutput only your contextual rephrasing. No explanations.\r\n`;\r\n\r\nexport interface FillerConfig {\r\n  /** Enable short filler (default: false) */\r\n  enableShortFiller?: boolean;\r\n  /** Enable long filler (default: false) */\r\n  enableLongFiller?: boolean;\r\n  /** Delay before short filler in ms (default: 5000) */\r\n  shortFillerDelayMs?: number;\r\n  /** Delay before long filler in ms (default: 10000) */\r\n  longFillerDelayMs?: number;\r\n  /** Fallback short filler text if LLM fails */\r\n  shortFillerFallback?: string;\r\n  /** Fallback long filler text if LLM fails */\r\n  longFillerFallback?: string;\r\n\r\n  // LLM Configuration\r\n  /** LLM API URL (required for dynamic fillers) */\r\n  llmApiUrl?: string;\r\n  /** LLM API Key */\r\n  llmApiKey?: string;\r\n  /** LLM Model name (default: \"deepseek-chat\") */\r\n  llmModel?: string;\r\n  /** Custom system prompt for short filler */\r\n  shortFillerPrompt?: string;\r\n  /** Custom system prompt for long filler */\r\n  longFillerPrompt?: string;\r\n  /** LLM request timeout in ms (default: 3000) */\r\n  llmTimeoutMs?: number;\r\n  /** Language hint for LLM (e.g., \"English\", \"Hindi\") */\r\n  languageHint?: string;\r\n\r\n  // TTS Configuration\r\n  /** TTS voice ID for filler synthesis (uses default if not set) */\r\n  ttsVoice?: string;\r\n\r\n  /** Callback when filler is generated */\r\n  onFillerGenerated?: (type: \"short\" | \"long\", text: string) => void;\r\n  /** Custom synthesizer function (overrides internal TTS if provided) */\r\n  synthesize?: (\r\n    text: string\r\n  ) => Promise<{ audio: Float32Array; sampleRate: number }>;\r\n}\r\n\r\nconst DEFAULT_CONFIG = {\r\n  enableShortFiller: false,\r\n  enableLongFiller: false,\r\n  shortFillerDelayMs: 5000,\r\n  longFillerDelayMs: 10000,\r\n  shortFillerFallback: \"Okay, I understand.\",\r\n  longFillerFallback: \"Right, that makes sense.\",\r\n  llmModel: \"deepseek-chat\",\r\n  shortFillerPrompt: SHORT_FILLER_SYSTEM_PROMPT,\r\n  longFillerPrompt: LONG_FILLER_SYSTEM_PROMPT,\r\n  llmTimeoutMs: 3000,\r\n  languageHint: \"English\",\r\n};\r\n\r\nexport class FillerManager {\r\n  private config: typeof DEFAULT_CONFIG &\r\n    Pick<\r\n      FillerConfig,\r\n      | \"llmApiUrl\"\r\n      | \"llmApiKey\"\r\n      | \"onFillerGenerated\"\r\n      | \"synthesize\"\r\n      | \"ttsVoice\"\r\n    >;\r\n\r\n  private speechStartedAt = 0;\r\n  private shortFillerTimer: ReturnType<typeof setTimeout> | null = null;\r\n  private longFillerTimer: ReturnType<typeof setTimeout> | null = null;\r\n  private shortFillerGenerated = false;\r\n  private longFillerGenerated = false;\r\n  private unsubscribe?: () => void;\r\n  private currentPartialTranscript = \"\";\r\n  private inFlight = 0;\r\n  private ttsLogic: TTSLogic | null = null;\r\n  private ttsInitPromise: Promise<void> | null = null;\r\n\r\n  // Exposed for consumer to see generated fillers\r\n  public shortFiller: string | null = null;\r\n  public longFiller: string | null = null;\r\n\r\n  constructor(config: FillerConfig = {}) {\r\n    this.config = { ...DEFAULT_CONFIG, ...config };\r\n    this.setupSpeechStateListener();\r\n    this.initializeTTS();\r\n  }\r\n\r\n  private initializeTTS(): void {\r\n    // Only initialize if no custom synthesizer is provided\r\n    if (!this.config.synthesize) {\r\n      this.ttsLogic = new TTSLogic({\r\n        voiceId: this.config.ttsVoice,\r\n        useSharedAudioPlayer: true, // Use shared player for queueing\r\n        warmUp: false,\r\n      });\r\n      this.ttsInitPromise = this.ttsLogic.initialize().catch((err) => {\r\n        console.error(\"[FillerManager] Failed to initialize TTS:\", err);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update configuration\r\n   */\r\n  configure(config: Partial<FillerConfig>): void {\r\n    this.config = { ...this.config, ...config };\r\n  }\r\n\r\n  /**\r\n   * Set the synthesizer function\r\n   */\r\n  setSynthesizer(synthesize: FillerConfig[\"synthesize\"]): void {\r\n    this.config.synthesize = synthesize;\r\n  }\r\n\r\n  /**\r\n   * Update partial transcript (call this on each STT partial result)\r\n   */\r\n  updatePartialTranscript(text: string): void {\r\n    this.currentPartialTranscript = text;\r\n  }\r\n\r\n  private setupSpeechStateListener(): void {\r\n    this.unsubscribe = internalSpeechState.onSpeakingChange((speaking) => {\r\n      if (speaking) {\r\n        this.onSpeechStart();\r\n      } else {\r\n        this.onSpeechEnd();\r\n      }\r\n    });\r\n  }\r\n\r\n  private onSpeechStart(): void {\r\n    this.speechStartedAt = Date.now();\r\n    this.shortFillerGenerated = false;\r\n    this.longFillerGenerated = false;\r\n    this.shortFiller = null;\r\n    this.longFiller = null;\r\n    this.currentPartialTranscript = \"\";\r\n\r\n    console.log(\"[FillerManager] Speech started, scheduling fillers\");\r\n\r\n    // Schedule short filler\r\n    if (this.config.enableShortFiller) {\r\n      this.shortFillerTimer = setTimeout(() => {\r\n        this.generateFiller(\"short\");\r\n      }, this.config.shortFillerDelayMs);\r\n    }\r\n\r\n    // Schedule long filler\r\n    if (this.config.enableLongFiller) {\r\n      this.longFillerTimer = setTimeout(() => {\r\n        this.generateFiller(\"long\");\r\n      }, this.config.longFillerDelayMs);\r\n    }\r\n  }\r\n\r\n  private onSpeechEnd(): void {\r\n    console.log(\"[FillerManager] Speech ended, clearing timers\");\r\n    this.clearTimers();\r\n    this.speechStartedAt = 0;\r\n  }\r\n\r\n  private clearTimers(): void {\r\n    if (this.shortFillerTimer) {\r\n      clearTimeout(this.shortFillerTimer);\r\n      this.shortFillerTimer = null;\r\n    }\r\n    if (this.longFillerTimer) {\r\n      clearTimeout(this.longFillerTimer);\r\n      this.longFillerTimer = null;\r\n    }\r\n  }\r\n\r\n  private async generateFiller(type: \"short\" | \"long\"): Promise<void> {\r\n    // Prevent duplicate generation\r\n    if (type === \"short\" && this.shortFillerGenerated) return;\r\n    if (type === \"long\" && this.longFillerGenerated) return;\r\n\r\n    // Mark as generated immediately to prevent race conditions\r\n    if (type === \"short\") {\r\n      this.shortFillerGenerated = true;\r\n    } else {\r\n      this.longFillerGenerated = true;\r\n    }\r\n\r\n    this.inFlight++;\r\n\r\n    let fillerText: string;\r\n\r\n    // Try LLM generation if configured\r\n    if (this.config.llmApiUrl && this.config.llmApiKey) {\r\n      try {\r\n        fillerText = await this.generateFillerWithLLM(type);\r\n        console.log(\r\n          `[FillerManager] LLM generated ${type} filler: \"${fillerText}\"`\r\n        );\r\n      } catch (error) {\r\n        console.error(`[FillerManager] LLM failed, using fallback:`, error);\r\n        fillerText =\r\n          type === \"short\"\r\n            ? this.config.shortFillerFallback\r\n            : this.config.longFillerFallback;\r\n      }\r\n    } else {\r\n      // Use fallback text\r\n      fillerText =\r\n        type === \"short\"\r\n          ? this.config.shortFillerFallback\r\n          : this.config.longFillerFallback;\r\n      console.log(\r\n        `[FillerManager] Using fallback ${type} filler: \"${fillerText}\"`\r\n      );\r\n    }\r\n\r\n    // Store generated filler\r\n    if (type === \"short\") {\r\n      this.shortFiller = fillerText;\r\n    } else {\r\n      this.longFiller = fillerText;\r\n    }\r\n\r\n    // Notify consumer\r\n    this.config.onFillerGenerated?.(type, fillerText);\r\n\r\n    // Synthesize and queue audio\r\n    try {\r\n      if (this.config.synthesize) {\r\n        // Use custom synthesizer if provided\r\n        const result = await this.config.synthesize(fillerText);\r\n        sharedAudioPlayer.addAudioIntoQueue(result.audio, result.sampleRate);\r\n      } else if (this.ttsLogic) {\r\n        // Use internal TTSLogic's synthesizeAndAddToQueue\r\n        if (this.ttsInitPromise) await this.ttsInitPromise;\r\n        await this.ttsLogic.synthesizeAndAddToQueue(fillerText);\r\n      } else {\r\n        console.warn(\"[FillerManager] No TTS available for filler synthesis\");\r\n      }\r\n      console.log(`[FillerManager] ${type} filler queued for playback`);\r\n    } catch (error) {\r\n      console.error(\r\n        `[FillerManager] Failed to synthesize ${type} filler:`,\r\n        error\r\n      );\r\n    }\r\n\r\n    this.inFlight--;\r\n  }\r\n\r\n  private async generateFillerWithLLM(type: \"short\" | \"long\"): Promise<string> {\r\n    const systemPrompt =\r\n      type === \"short\"\r\n        ? this.config.shortFillerPrompt\r\n        : this.config.longFillerPrompt;\r\n\r\n    const userMessage = [\r\n      `Language: ${this.config.languageHint}`,\r\n      \"\",\r\n      \"Current user speech (partial):\",\r\n      `\"${this.currentPartialTranscript || \"(no transcript yet)\"}\"`,\r\n      \"\",\r\n      this.shortFiller\r\n        ? `Previous short filler already generated: \"${this.shortFiller}\"`\r\n        : \"\",\r\n      \"\",\r\n      \"Output only your natural brief reaction.\",\r\n    ]\r\n      .filter(Boolean)\r\n      .join(\"\\n\");\r\n\r\n    const controller = new AbortController();\r\n    const timeout = setTimeout(\r\n      () => controller.abort(),\r\n      this.config.llmTimeoutMs\r\n    );\r\n\r\n    try {\r\n      const response = await fetch(this.config.llmApiUrl!, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n          Authorization: `Bearer ${this.config.llmApiKey}`,\r\n        },\r\n        body: JSON.stringify({\r\n          model: this.config.llmModel,\r\n          messages: [\r\n            { role: \"system\", content: systemPrompt },\r\n            { role: \"user\", content: userMessage },\r\n          ],\r\n          stream: false,\r\n        }),\r\n        signal: controller.signal,\r\n      });\r\n\r\n      clearTimeout(timeout);\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`LLM API error: ${response.status}`);\r\n      }\r\n\r\n      const data = await response.json();\r\n      const content = data.choices?.[0]?.message?.content || \"\";\r\n      return content.trim().slice(0, 100) || this.getFallback(type);\r\n    } catch (error) {\r\n      clearTimeout(timeout);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private getFallback(type: \"short\" | \"long\"): string {\r\n    return type === \"short\"\r\n      ? this.config.shortFillerFallback\r\n      : this.config.longFillerFallback;\r\n  }\r\n\r\n  /**\r\n   * Manually trigger a filler (useful for testing)\r\n   */\r\n  async triggerFiller(type: \"short\" | \"long\"): Promise<void> {\r\n    await this.generateFiller(type);\r\n  }\r\n\r\n  /**\r\n   * Reset state for new session\r\n   */\r\n  reset(): void {\r\n    this.clearTimers();\r\n    this.speechStartedAt = 0;\r\n    this.shortFillerGenerated = false;\r\n    this.longFillerGenerated = false;\r\n    this.shortFiller = null;\r\n    this.longFiller = null;\r\n    this.currentPartialTranscript = \"\";\r\n  }\r\n\r\n  /**\r\n   * Cleanup\r\n   */\r\n  destroy(): void {\r\n    this.clearTimers();\r\n    if (this.unsubscribe) {\r\n      this.unsubscribe();\r\n    }\r\n  }\r\n}\r\n\r\n// Singleton instance for internal use\r\nlet fillerManagerInstance: FillerManager | null = null;\r\n\r\nexport function getFillerManager(): FillerManager {\r\n  if (!fillerManagerInstance) {\r\n    fillerManagerInstance = new FillerManager();\r\n  }\r\n  return fillerManagerInstance;\r\n}\r\n\r\nexport function configureFillerManager(config: FillerConfig): FillerManager {\r\n  const manager = getFillerManager();\r\n  manager.configure(config);\r\n  return manager;\r\n}\r\n"]}